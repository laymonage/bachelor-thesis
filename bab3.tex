%-----------------------------------------------------------------------------%
\chapter{\babTiga}
%-----------------------------------------------------------------------------%

This chapter explains the design and analysis of the \code{JSONField}
implementation, as well as \code{JSONField} data validation examples.

%-----------------------------------------------------------------------------%
\section{\code{JSONField}}
%-----------------------------------------------------------------------------%

There are two kinds of \code{JSONField}: the model field and the form field.
The model field is used as an abstraction of the JSON data in the database,
which lets its users manipulate JSON data in the form of Python objects.
The form field is used for accepting JSON data in forms, such as a Django
\code{ModelForm}. Both fields can be validated using Django's built-in
validation feature with custom-made validator functions.

The model field holds JSON data that can be stored to and retrieved from the
database. In Python, the data is represented in Python's built-in formats:
dictionaries, lists, strings, numbers, booleans, and \code{None}. When saving
the model, Django executes an SQL \code{INSERT} or \code{UPDATE} query to the
database. In order to pass the JSON data in the SQL query, the data has to be
serialized into a JSON-encoded string. When retrieving the model instance,
Django executes an SQL \code{SELECT} query to the database. The data is
retrieved as a JSON-encoded string, which needs to be deserialized, or decoded,
into a Python object.

\begin{figure}
	\centering
    \includegraphics[width=0.66\textwidth]{pics/encodecode.png}
	\caption{The use of the \code{json.dumps()} and \code{json.loads()}
	functions to encode a Python object and decode a JSON-encoded string,
	respectively.}
	\label{fig:encodecode}
\end{figure}

To serialize/deserialize Python objects into/from JSON-encoded strings, the
built-in \code{json} library in Python can be used \cite{python:json}. The
encoding and decoding functionalities are provided through the
\code{json.dumps()} and \code{json.loads()} functions, respectively, as shown
in \autoref{fig:encodecode}. By default, the \code{json.dumps()} function uses
the \code{json.JSONEncoder} class, while the \code{json.loads()} function uses
the \code{json.JSONDecoder} class. These classes support the Python
\code{dict}, \code{list}, \code{str}, \code{int}, \code{float}, \code{True},
\code{False}, and \code{None} data types and objects. To support other data
types and objects, customized \code{json.JSONEncoder} and
\code{json.JSONDecoder} subclasses can be used for the functions by supplying
the subclass as the \code{cls} argument.

The form field utilizes the \code{json} library for serialization and
deserialization when handling JSON input from the client. If the data being
deserialized is not a valid JSON document, the \code{json.loads()} function
will raise a \code{JSONDecodeError}. This error is used by Django to provide
a basic validation functionality by catching the error and raising a
\code{ValidationError} instead.

\begin{table}
	\centering
	\texttt{
\begin{tabular}{|c|c|c|c|}
\hline
\no{Python}    & \no{JSON} & \no{SQL}            & \no{JSON-encoded string} \\ \hline
'' \no{or} ""  & ""        & ''                  & '""'                     \\ \hline
\{\}           & \{\}      & \no{not applicable} & '\{\}'                   \\ \hline
[]             & []        & \no{not applicable} & '[]'                     \\ \hline
None           & null      & NULL                & 'null'                   \\ \hline
\end{tabular}
}
	\caption{Comparison of empty values and their equivalents in Python, JSON, and SQL.
	The "JSON-encoded string" column shows the Python values after serialization
	with \code{json.dumps()}.}
	\label{table:emptyvalues}
\end{table}

When serializing and deserializing JSON data for the model field, the Python
\code{None} object, the JSON \code{null} value, and the SQL \code{NULL} value
should be taken into consideration. The model field uses JSON-encoded strings
to store JSON values, as there are no SQL equivalents for JSON objects and
arrays. Following the patterns of other values shown in
\autoref{table:emptyvalues}, the \code{None} object should be stored as the
JSON-encoded \code{'null'} string on the database. However, according to the
Python DB-API 2.0 specification (which Django follows), the \code{None} object
is reserved for the SQL \code{NULL} value for both input and output
\cite{db-api2}. Therefore, the model field should skip the serialization and
deserialization for \code{None} (if it's stored as the top-level value) and let
the database driver store it as SQL \code{NULL}.

In order to store and query the JSON \code{null} value as the top-level value
of \code{JSONField}, the \code{Value} class from the \code{django.db.models}
module can be utilized. A \code{Value()} object wraps a literal SQL value to be
used in an SQL expression \cite{django:value}. This literal SQL value is not
processed by Django. In the case of \code{JSONField}, that means the value is
not passed into the \code{json.dumps()} function. Therefore, the JSON
\code{null} value can be stored as a JSON-encoded SQL string literal (i.e.
\code{Value('null')}), which will be stored as \code{'null'}, not
\code{'"null"'} and not \code{NULL}.

\noindent
\begin{minipage}{\linewidth}
\lstinputlisting[language=Python, caption={A \code{Dog} model with a
\code{CharField} for its name and a \code{JSONField} for additional data.},
label=code:dog]{codes/3-dog.py}
\end{minipage}

\noindent
\begin{minipage}{\linewidth}
\lstinputlisting[language=Python, caption={\code{JSONField} behavior with
SQL \code{NULL} and JSON \code{null}.},
label=code:null]{codes/3-null.py}
\end{minipage}

However, when retrieved from the database, both SQL \code{NULL} and
JSON-encoded \code{'null'} are represented in Python with \code{None}. This
happens because Django processes the \code{'null'} value using
\code{json.loads()}, which will return \code{None}. When \code{None} is saved
as a top-level value in the database, it will be saved as SQL \code{NULL}.
Meanwhile, when querying, \code{None} is always interpreted as JSON
\code{null}. To query for SQL \code{NULL}, the \code{isnull} lookup is used.
\autoref{code:null} shows a demonstration of how storing and querying SQL
\code{NULL} and JSON \code{null} work with a \code{JSONField} defined in the
\code{Dog} model shown in \autoref{code:dog}. This behavior may cause confusion
as discussed on the GitHub pull request shown
in \autoref{fig:nulldiscussion}.\footnote{\url{
	https://github.com/django/django/pull/11452\#discussion\_r335375254}}
To avoid this confusion, Django does not recommend working with JSON
\code{null} as the top-level value of \code{JSONField}.

\begin{figure}
	\centering
    \includegraphics[width=1.0\textwidth]{pics/null_discussion.png}
	\caption{A brief discussion regarding the use of JSON \code{null} as the
	top-level value of a \code{JSONField}.}
	\label{fig:nulldiscussion}
\end{figure}

As with string-based fields such as \code{CharField} and \code{TextField},
Django recommends avoiding the use of SQL \code{NULL} for \code{JSONField}. If
the SQL \code{NULL} is used on a string-based field, it means that there are
two possible values for "no data": \code{NULL} and the empty string
(\code{''}). On \code{JSONField}, it means that there are the empty JSON object
(\code{'\{\}'}), the empty JSON array (\code{'[]'}), the empty JSON string
(\code{'""'}), the JSON \code{null} value (\code{'null'}), and the SQL
\code{NULL}. To avoid redundancy, Django recommends setting \code{null=False}
(to enforce database-level \code{NOT NULL} constraint) and providing a suitable
default for empty values, such as \code{default=dict}.

To ensure that the data inserted into the database is valid JSON, the model
field can also define the SQL \code{CHECK} constraints on the database-level.
On MariaDB and SQLite, the \code{JSON\_VALID} function can be used as a
\code{CHECK} constraint. On Oracle Database, the \code{IS JSON} condition can
be applied to the table column. On PostgreSQL and MySQL, the JSON data is
automatically validated when using the \code{JSON} data type (or \code{JSONB}
on PostgreSQL). These constraints only validate the syntax of the JSON data and
not the information contained within the data.

This section has covered the design of \code{JSONField} in terms of storing and
loading JSON data. In addition to storing and loading data, the ORM system in
Django also provides querying capabilities by translating Python method calls
into SQL \code{SELECT} queries. In order to fully utilize Django's ORM, the
lookups and transforms features of the ORM can be extended to use the JSON
functions provided by the database systems.

%-----------------------------------------------------------------------------%
\section{\code{JSONField} Lookups and Transforms}
%-----------------------------------------------------------------------------%

To query JSON data, the previous implementation of \code{JSONField} included
\code{JSONField}-specific lookups and transforms. The lookups and transforms
consisted of containment lookups, key existence lookups, and path transforms.
These lookups and transforms were implemented by using JSON operators that are
only available on PostgreSQL. To implement them on other database systems,
those operators need to be substituted with their JSON function equivalents.
The lookups will be demonstrated using the \code{Dog} model from
\autoref{code:dog} with the objects created in \autoref{code:dogobjects}.

\noindent
\begin{minipage}{\linewidth}
\lstinputlisting[language=Python, caption={Some \code{Dog} objects created with
different JSON data.},
label=code:dogobjects]{codes/3-dogobjects.py}
\end{minipage}

\noindent
\begin{minipage}{\linewidth}
\lstinputlisting[language=Python, caption={A demonstration of how the
\code{contains} and \code{contained\_by} lookups are used.},
label=code:containment]{codes/3-containment.py}
\end{minipage}

The containment lookups consist of the \code{contains} and \code{contained\_by}
lookups. The \code{contains} lookup is overridden on \code{JSONField}.
Normally, it is used to query for strings using a case-sensitive substring
containment test. On \code{JSONField}, it is used to query for JSON data using
a subset containment test. The query will return objects with JSON data that
contains the lookup value as a subset. Meanwhile, the \code{contained\_by}
lookup is the inverse: it looks for objects with JSON data that is contained by
the lookup value. The \code{contains} and \code{contained\_by} lookups are
demonstrated in \autoref{code:containment}.

The containment lookups can be implemented using JSON operators or JSON
functions provided by some of the database systems. On PostgreSQL, the
\code{contains} and \code{contained\_by} lookups can be implemented using the
\code{@>} and \code{<@} operators, respectively. On MariaDB and MySQL, both
lookups can be implemented using the \code{JSON\_CONTAINS} function by
switching the first and second arguments for the \code{contained\_by} lookup.
Unfortunately, SQLite and Oracle Database do not have a similar function, so
these lookups are left unsupported on both databases.

\noindent
\begin{minipage}{\linewidth}
\lstinputlisting[language=Python, caption={A demonstration of how the
\code{has\_key}, \code{has\_keys}, and \code{has\_any\_keys} lookups are
used.},
label=code:keyexistence]{codes/3-keyexistence.py}
\end{minipage}

The key existence lookups consist of the \code{has\_key}, \code{has\_keys}, and
\code{has\_any\_keys} lookups. The \code{has\_key} lookup is used to query for
objects where the given key is in the top-level of the JSON data. The
\code{has\_keys} lookup is similar to \code{has\_key}, but it accepts a list of
strings and it is used to query for objects where all of the given keys are
in the top-level of the JSON data. The \code{has\_any\_keys} lookup is similar
to \code{has\_keys}, but the objects only need to have at least one of the
given keys in the top-level of the JSON data. These lookups are demonstrated in
\autoref{code:keyexistence}.

As with the containment lookups, the key existence lookups can be implemented
using JSON operators or JSON functions on the database systems. On PostgreSQL,
the \code{has\_key}, \code{has\_keys}, and \code{has\_any\_keys} lookups can be
implemented using the \code{?}, \code{?\&}, and \code{?|} operators,
respectively. On MariaDB and MySQL, these lookups can be implemented using the
\code{JSON\_CONTAINS\_PATH} function. This function accepts multiple paths as
its arguments and there's a \code{one\_or\_all} argument that determines
whether the JSON data should contain at least one path or all of the paths. On
SQLite, there's no function that is similar to \code{JSON\_CONTAINS\_PATH}, but
the \code{JSON\_TYPE} with the \code{IS NOT NULL} condition can be used to
determine whether a given path exists. On Oracle Database, a similar
functionality can be obtained using the \code{JSON\_EXISTS} function. Both
SQLite and Oracle Database need to chain the function calls with the \code{AND}
and \code{OR} operators for the \code{has\_keys} and \code{has\_any\_keys}
lookups, respectively.

\noindent
\begin{minipage}{\linewidth}
\lstinputlisting[language=Python, caption={A demonstration of how the
key, index, and path transforms are used.},
label=code:transforms]{codes/3-transforms.py}
\end{minipage}

The key, index, and path transforms can be used to query based on a certain
location in the JSON data as shown in \autoref{code:transforms}. To query based
on a given key, the key can be used as the transform name (e.g.
\code{data\_\_breed}). To query based on a given path, multiple keys can be
chained together using a double underscore (e.g. \code{data\_\_owner\_\_name}).
An integer key is interpreted as an array index.

The path transforms can be chained with Django's built-in lookups (e.g.
\code{startswith}, \code{regex}) and the \code{JSONField}-specific lookups
described in the previous paragraphs. If the lookup is not specified, the
\code{exact} lookup is used. If the value for the \code{exact} lookup is
\code{None}, it will be interpreted as JSON \code{null}. To query for missing
keys, the \code{isnull} lookup can be used.

To implement the path transforms, the JSON value specified at the given path
should be extracted. On PostgreSQL, this functionality can be achieved by using
the \code{->} operator for shallow paths and the \code{\#>} operator for nested
paths. On MariaDB, MySQL, and SQLite, the \code{JSON\_EXTRACT} function can be
used. On Oracle Database, extraction can be done using the \code{JSON\_VALUE}
function to extract scalar values and the \code{JSON\_QUERY} function to
extract JSON objects and JSON arrays. When the transforms are chained with
lookups that expect a string value on the left-hand side, the
\code{JSON\_UNQUOTE} function should be used on MariaDB and MySQL to unquote
the JSON double quotes. Meanwhile, on PostgreSQL, the \code{->>} and
\code{\#>>} operators are used for these lookups instead of the \code{->} and
\code{\#>} operators.

This and the previous sections have described how \code{JSONField} and its
extended querying capabilities are designed. As previously described, the
database systems provide basic validation functionality by checking the syntax
of the JSON data. To validate the information within the JSON data, additional
checks can be implemented on the application-level as covered in the next
section.
