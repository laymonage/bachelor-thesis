%-----------------------------------------------------------------------------%
\chapter{\babSatu}
%-----------------------------------------------------------------------------%

This chapter explains the background of this research and the problem to be
solved by this research.

%-----------------------------------------------------------------------------%
\section{Research Background}
%-----------------------------------------------------------------------------%

When the web platform was in its early stages, every part of a web application
was programmed manually. At that time, developing a web application required
extensive knowledge of how the web works. Depending on the web application, the
programmers might need deep understanding of the Hypertext Transfer Protocol
(HTTP), the Hypertext Markup Language (HTML), and other things such as
databases. If the web application was not programmed correctly, it could lead
to a lot of errors and security holes in the web application.

Web frameworks aim to solve this problem by providing a standard way to build
web applications. Web frameworks help eliminate the overhead of implementing
common parts of web applications such as the HTTP layer, the user interface
layer, and the database layer. By using a web framework, programmers can build
web applications more quickly and safely by focusing more on the business logic
of the web application itself instead of the more intricate details.

Among the widely-used web frameworks is Django, a free and open-source web
framework written in Python.\footnote{\url{https://djangoproject.com}} One of
the main features of Django is an object-relational mapping (ORM) tool in the
database layer. Django's ORM tool provides an object-oriented abstraction of
the database by mapping data models (represented as Python classes) to tables
in a relational database. The columns of a database table are defined as
attributes (called fields) inside the model class \cite{django}. Using Django's
ORM tool, programmers can interact with the database by writing Python code
instead of writing Structured Query Language (SQL) statements. The abstraction
provided by Django's ORM tool also helps programmers avoid common mistakes that
can lead to security issues such as SQL injections.

Relational database systems can be used to manage structured data in the form
of tables with strict standards. The tables in a relational database can be
linked (related) based on data that is common to each table. Relating the
tables is possible because relational database systems enforce the data to be
consistent with a defined schema. This consistency is implemented according to
the Atomicity, Consistency, Isolation, and Durability (ACID) properties of
relational database transactions \cite{abramova_nosql}. These properties
guarantee that the data is valid despite any events of power failures, errors,
and other accidents.

Meanwhile, there has been an increase in the popularity of non-relational
databases, commonly known as NoSQL databases \cite{paul_nosql}. NoSQL
encourages the simplicity of database design, which makes the process of
scaling the database to multiple clusters of machines easier
\cite{leavitt_nosql}. Instead of tables, most NoSQL databases store data in the
form of key-value stores, document stores, or graphs \cite{strauch_nosql}.
NoSQL databases are also considered as more flexible due to its dynamic schema.
For example, some document-based NoSQL databases store data in JavaScript
Object Notation (JSON) format, which means that the schema is defined in the
data itself.

However, NoSQL databases also have their own downsides. Most NoSQL databases do
not fully support the ACID principles found in relational databases
\cite{cattell_nosql}. Instead of the ACID principles, they focus on the
Basically Available, Soft state, and Eventually consistent (BASE) principles
\cite{abramova_nosql}. The BASE principles state that the data should be
available most of the time (it can support partial failures), the data does not
have to be consistent at all times (soft state), but the data is guaranteed to
be consistent at some point (eventually). In addition, they also lack the
ability to perform joins across tables due to their horizontal data
distribution \cite{pokorny_nosql} and the use of denormalized data, which makes
it harder to deal with entity relations.

Nowadays, some relational database systems have come up with their own
solutions of providing more flexibility for the data model. Some of them
provide the option to combine structured data with some form of semi-structured
data, most commonly in JSON format \cite{mariadb_json}. This combination gives
all the benefits of using a relational database, while still allowing the
simplicity and flexibility of semi-structured data.

From version 1.9 until version 3.0, Django had provided an implementation of
JSONField. However, it was exclusively available for PostgreSQL. This JSONField
allowed its users to store and query JSON data in a relational database column
using the jsonb data type found only on PostgreSQL at the time. Django
officially supports PostgreSQL, SQLite, MySQL, MariaDB, and Oracle Database
backends. Over the years since the initial PostgreSQL JSONField implementation,
those database systems have developed their own support for dealing with JSON
data. However, Django had yet to implement JSONField for database backends
other than PostgreSQL.

The limited support for JSONField prompted the Django community to create their
own JSONField implementations for other database backends. Some of them target
one specific database backend and utilize various functions provided by the
database system to add extended querying capabilities \cite{mysql_jsonfield}
\cite{oracle_jsonfield}. Some other implementations focus on cross-database
support, so they are only implemented as text-based fields that do not have any
extended querying capabilities \cite{ryan_jsonfield}.

The individual efforts for implementing JSONField result in the abundance of
third-party JSONField packages on PyPI.\footnote{The Python Package Index
(PyPI) is a software repository for the Python programming language.} Some
of them are very popular, such as the jsonfield package that has more than 1100
stars on GitHub \cite{ryan_jsonfield}. While this indicates a popular demand
for JSONField, it also indicates a fragmentation problem as people use
different JSONField packages. Thus, there's a motivation to bring JSONField
into Django's core model fields.

The flexibility of JSON data in a JSONField might introduce invalid information
or abnormalities within the data. For example, the data might refer to a
nonexisting record in one of the database tables. This kind of invalid
information is possible because the database only checks whether the data is
valid JSON (in terms of syntax) by default. The database does not check the
information contained within the JSON data. To ensure the correctness of
JSONField data, additional validations need to be implemented.

Relational databases are not dedicated for storing JSON data, so they may not
perform well compared to NoSQL databases. However, recent benchmarks by
EnterpriseDB showed that PostgreSQL outperformed MongoDB in varied workloads
\cite{enterprisedb_benchmark}.\footnote{MongoDB is one of the most popular
document-oriented NoSQL database systems.} Some extensive benchmarks on
PostgreSQL, MySQL, and MongoDB also showed that the performance differences
were not significant, especially for smaller documents \cite{dolgov_benchmark}.
However, these benchmarks were done directly on the database systems instead
of using an ORM tool. Therefore, further studies of relational databases'
performance on handling JSON data using an ORM tool would provide new insights
on this topic.

With the motivations described in the previous paragraphs, this research aims
to implement JSONField in Django, demonstrate additional validations for
JSONField, and provide an analysis of JSONField performance. The new
implementation of JSONField would have cross-database support, extended
querying support, and compatibility with the previous JSONField implementation.
Additional validations for JSONField would be demonstrated by creating a Django
project that would utilize Django's validation features. Finally, the JSON
performance analysis would be done on all database systems supported by Django,
using Django's ORM tool in a Django project. If these targets were achieved,
they would hopefully benefit the Django community by making JSONField available
from within Django itself, with additional validation examples, and performance
insights for consideration of using JSONField.

%-----------------------------------------------------------------------------%
\section{Research Questions}
%-----------------------------------------------------------------------------%

Based on the aforementioned research background, the following questions are
constructed for this research:

\begin{enumerate}
    \item How can JSONField in Django be reimplemented with cross-database
          support and compatibility with the previous JSONField implementation?
    \item How can Django users enforce validation rules on a JSONField?
    \item How is the performance of the cross-database JSONField on all of the
          database backends supported by Django?
\end{enumerate}

%-----------------------------------------------------------------------------%
\section{Research Objectives}
%-----------------------------------------------------------------------------%

The objectives of this research are to:

\begin{itemize}
    \item Implement a new JSONField that can be used on all database backends
          supported by Django.
    \item Demonstrate how semi-structured data in a JSONField can be validated.
    \item Provide a performance analysis of JSONField across different database
          backends.
\end{itemize}

%-----------------------------------------------------------------------------%
\section{Research Benefits}
%-----------------------------------------------------------------------------%

This research would hopefully bring the following benefits:

\begin{itemize}
    \item Provide Django users with a JSONField that has a consistent
          experience on all database backends supported by Django.
    \item Give insights to Django users about the inner workings, validation
          examples, and performance considerations of JSONField.
\end{itemize}

%-----------------------------------------------------------------------------%
\section{Research Scope}
%-----------------------------------------------------------------------------%

The following assumptions were made prior to the execution of this research:

\begin{itemize}
    \item The JSONField implementation would be submitted as a pull request and
          merged to the upstream Django repository instead of being made as a
          separate package.
    \item The primary focus of this research would be on implementing the model
          field type of JSONField, with the form field type as a secondary
          priority.
    \item The JSONField implementation has to take into account the limitations
          of each database backend, so there may be features that behave
          differently or are not supported on some database backends.
\end{itemize}

%-----------------------------------------------------------------------------%
\section{Research Position}
%-----------------------------------------------------------------------------%

This research is mainly split by two parts: the JSONField implementation and
the analysis demonstrations. The JSONField implementation part of the research
would be done on a Git branch in a GitHub fork of the Django repository. The
branch would be submitted as a pull request to the Django repository. This
would allow the Django contributors to review the code and give feedback on the
implementation. The data validation and performance benchmarking analysis
demonstrations would be done in a separate repository in the form of two small
Django projects.

\todo{Add a picture that illustrates this.}

The JSONField implementation would be done as part of the Google Summer of Code
2019 program. Google Summer of Code (GSoC) is an annual program held by Google
that's focused on introducing students to open-source software development. In
GSoC, students work on a 3 month programming project under the guidance of
mentors from an open-source organization. The students are compensated with a
stipend from Google for their work. In turn, the organizations can identify and
bring in new contributors who implement new features and hopefully continue to
contribute to the organizations' projects.

\begin{figure}
	\centering
    \includegraphics[width=0.25\textwidth]{pics/GSoC.png}
	\captionsource{The Google Summer of Code logo.}{\url{
        https://developers.google.com/open-source/gsoc/resources/marketing}}
	\label{fig:gsoc}
\end{figure}

%-----------------------------------------------------------------------------%
\section{Research Steps}
%-----------------------------------------------------------------------------%

The following steps were conducted for the research:

\begin{enumerate}
    \item Literature review \\
    This step focused on reading and understanding how the Django
    object-relational mapping (ORM) tool works, as well as JSON support on the
    database backends supported by Django. During this step, the underlying
    concepts of this research were studied in order to accomplish the research
    objectives.

    \item Experiments \\
    In this step, experiments were done by trying out existing JSONField
    implementations, which included the PostgreSQL implementation in Django,
    as well as third-party packages on the Python Package Index (PyPI). Some
    experiments were also done by modifying a third-party package to work
    better on different database backends.

    \item Implementation \\
    This step focused on the implementation of the JSONField model and form
    fields. This was initially done by copying the existing implementation
    from the django.contrib.postgres module to the django.db.models and
    django.forms modules. The tests for the existing implementation were also
    copied. From there, the work was to modify the JSONField implementation so
    that all tests could pass on all available database backends.

    After the JSONField implementation, this step was continued by implementing
    the data validation example and benchmarking. This included the creation of
    two small Django projects for demonstration purposes.

    \item Results Analysis \\
    In this step, the primary work was to document the different behaviors and
    support of the JSONField implementation on each database backend. This step
    also included analyzing the data validation and benchmarking
    implementations. For the benchmark, the analysis included comparing the
    performance of JSONField on all database backends.
\end{enumerate}

%-----------------------------------------------------------------------------%
\section{Report Structure}
%-----------------------------------------------------------------------------%

The structure of this report is as follows:

\begin{itemize}
    \item Chapter 1 \babSatu \\
        This chapter covers the background, problem definition, objectives,
        scope, position, and steps of this research.
    \item Chapter 2 \babDua \\
        This chapter covers the results of the literature review done prior to
        executing the research.
    \item Chapter 3 \babTiga \\
        This chapter covers the plan and problem analysis to prepare for the
        implementation.
    \item Chapter 4 \babEmpat \\
        This chapter covers the JSONField, the data validation example, and
        the benchmarking implementations.
    \item Chapter 5 \babLima \\
        This chapter covers the analysis of the implementation results. This
        also covers the comparison of the benchmarking results between the
        database backends.
    \item Chapter 6 \kesimpulan \\
        This chapter covers the conclusions of the research and some
        recommendations for further research.
\end{itemize}
