%-----------------------------------------------------------------------------%
\chapter{\babEmpat}
%-----------------------------------------------------------------------------%

This chapter explains the implementation of \code{JSONField} and
\code{JSONField}-specific lookups and transforms that can be used on all
database backends supported by Django.

%-----------------------------------------------------------------------------%
\section{\code{JSONField}}
%-----------------------------------------------------------------------------%

In the Django codebase, model fields are defined in the
\code{django.db.models.fields} module as subclasses of \code{Field}, but they
can be imported from the \code{django.db.models} module for simplicity. Model
fields that are relatively simple are implemented in the \verb|__init__.py|
file of the module. For model fields that require more complex implementation
(e.g. file fields and relational fields), they are defined in their own files
in the \code{fields} directory. Due to the complexity of \code{JSONField} and
its extended querying capabilities, the implementation is defined in the
\code{json.py} file in the \code{fields} directory.

\listing
{Python}
{The \code{get\_prep\_value()} method of \code{JSONField}.}
{code:jsonfield-ser}
{codes/4-jsonfield-ser.py}

In the previous chapter, \code{JSONField} is designed to serialize Python
objects into JSON-encoded strings by utilizing the built-in \code{json} library
in Python. The serialization process is needed in order to store Python objects
as JSON in the database. To convert Python objects to query values, the
\verb|get_prep_value()| method should be overridden. The serialization is shown
by line 7 of \autoref{code:jsonfield-ser}, where the Python object is passed
to the \verb|json.dumps()| function, which also accepts an optional encoder
class as the \verb|cls| argument. Lines 5 and 6 of the listing show that the
\verb|None| value should not be serialized, because it is reserved for SQL
\verb|NULL| as previously explained.

\listing
[0 pt]{Python}
{The \code{from\_db\_value()} method of \code{JSONField}.}
{code:jsonfield-des}
{codes/4-jsonfield-des.py}

\code{JSONField} is also designed to deserialize JSON-encoded strings to Python
objects. The deserialization process is needed in order to load JSON data from
the database as Python objects. To convert database values to Python objects,
the \verb|from_db_value()| method can be overridden. The deserialization
process is shown by line 8 of \autoref{code:jsonfield-des}, where the database
value is passed to the \verb|json.loads()| function, which also accepts an
optional decoder class as the \verb|cls| argument. When extracting JSON scalar
values, the database systems return them in deserialized forms, which may cause
\verb|json.JSONDecodeError| to be raised. Therefore, the \verb|json.loads()|
call is put inside a \verb|try ... except| block, and the value is directly
returned if \verb|json.JSONDecodeError| is raised. Like
\verb|get_prep_value()|, the \verb|None| value is reserved for SQL \verb|NULL|,
as shown by lines 5 and 6 of the listing.

\listing
{Python}
{The \code{\_\_init\_\_()} method (constructor) of \code{JSONField}.}
{code:jsonfield-init}
{codes/4-jsonfield-init.py}

The custom encoder and decoder are stored as instance attributes of the field,
as shown by lines 16 and 17 of \autoref{code:jsonfield-init}. It is important
to note that the encoder and decoder are subclasses of \verb|json.JSONEncoder|
and \verb|json.JSONDecoder|, rather than instances of those classes. In Python,
a class is a callable that returns an instance of the class, so the encoder and
decoder have to be callables. To enforce this requirement, the \verb|JSONField|
constructor checks whether the encoder and decoder are callables and raises
descriptive error messages if they are not, as shown by lines 8 to 15 of the
listing.

\listing
{Python}
{The \code{deconstruct()} method of \code{JSONField}.}
{code:jsonfield-dec}
{codes/4-jsonfield-dec.py}

In order to preserve the encoder and decoder classes in database migrations,
the \verb|deconstruct()| method needs to be overridden. The method returns a
4-tuple that consists of: the name of the field on the model, the import path
of the field, a list of positional arguments, and a dictionary of keyword
arguments \cite{django:model_fields}. These values will be used to reconstruct
the field from a database migration. The encoder and decoder are defined as
keyword arguments of the constructor. Therefore, the \verb|deconstruct()|
method is overridden to add the encoder and decoder classes (if they are set,
i.e. not \verb|None|) to the keyword arguments dictionary, as shown by lines 6
to 9 of \autoref{code:jsonfield-dec}.

\listing
{Python}
{The \code{formfield()} method of \code{JSONField}.}
{code:jsonfield-form}
{codes/4-jsonfield-form.py}

When model fields are included in a \verb|ModelForm|, Django automatically
generate form fields for them. The form fields are generated by calling the
\verb|formfield()| method of the model field. In order to use the encoder and
decoder from the \verb|JSONField| model field in the \verb|JSONField| form
field, they need to be passed as keyword arguments, as shown by lines 7 and 8
of \autoref{code:jsonfield-form}.

%-----------------------------------------------------------------------------%
\section{laporan\_setting.tex}
%-----------------------------------------------------------------------------%
Berkas ini berguna untuk mempermudah pembuatan beberapa template standar.
Anda diminta untuk menuliskan judul laporan, nama, npm, dan hal-hal lain yang dibutuhkan untuk pembuatan template.


%-----------------------------------------------------------------------------%
\section{istilah.tex}
%-----------------------------------------------------------------------------%
Berkas istilah digunakan untuk mencatat istilah-istilah yang digunakan.
Fungsinya hanya untuk memudahkan penulisan.
Pada beberapa kasus, ada kata-kata yang harus selalu muncul dengan tercetak miring atau tercetak tebal.
Dengan menjadikan kata-kata tersebut sebagai sebuah perintah \latex~tentu akan mempercepat dan mempermudah pengerjaan laporan.


%-----------------------------------------------------------------------------%
\section{hype.indonesia.tex}
%-----------------------------------------------------------------------------%
Berkas ini berisi cara pemenggalan beberapa kata dalam bahasa Indonesia.
\latex~memiliki algoritma untuk memenggal kata-kata sendiri, namun untuk beberapa kasus algoritma ini memenggal dengan cara yang salah.
Untuk memperbaiki pemenggalan yang salah inilah cara pemenggalan yang benar ditulis dalam berkas \f{hype.indonesia.tex}.


%-----------------------------------------------------------------------------%
\section{pustaka.tex}
%-----------------------------------------------------------------------------%
Berkas pustaka.tex berisi seluruh daftar referensi yang digunakan dalam
laporan.
Anda bisa membuat model daftar referensi lain dengan menggunakan bibtex.
Untuk mempelajari bibtex lebih lanjut, silahkan buka \url{http://www.bibtex.org/Format}.
Untuk merujuk pada salah satu referensi yang ada, gunakan perintah \bslash cite, e.g. \bslash cite\{book:sample\} yang akan akan memunculkan \cite{book:sample}.


%-----------------------------------------------------------------------------%
\section{bab[1 - 6].tex}
%-----------------------------------------------------------------------------%
Berkas ini berisi isi laporan yang Anda tulis.
Setiap nama berkas e.g. bab1.tex merepresentasikan bab dimana tulisan tersebut akan muncul.
Sebagai contoh, kode dimana tulisan ini dibaut berada dalam berkas dengan nama \code{bab4.tex}.
Ada enam buah berkas yang telah disiapkan untuk mengakomodir enam bab dari laporan Anda, diluar bab kesimpulan dan saran.
Jika Anda tidak membutuhkan sebanyak itu, silahkan hapus kode dalam berkas \code{thesis.tex} yang memasukan berkas \latex~yang tidak dibutuhkan; contohnya perintah \code{\bslash{}include\{bab6.tex\}} merupakan kode untuk memasukan berkas \code{bab6.tex} kedalam laporan.
