%-----------------------------------------------------------------------------%
\chapter{\babEmpat}
%-----------------------------------------------------------------------------%

This chapter explains the implementation of \code{JSONField} and
\code{JSONField}-specific lookups and transforms that can be used on all
database backends supported by Django.

%-----------------------------------------------------------------------------%
\section{Database Backend Adjustments}
%-----------------------------------------------------------------------------%

Before implementing the \verb|JSONField| class, it is important to remember
that there are differences between the database systems in regards to handling
JSON data. For example, each database system uses a different data type to
store JSON data. In addition, the database driver (e.g. Psycopg 2 for
PostgreSQL) may automatically deserialize JSON data into Python objects. These
differences need to be taken into account when implementing \verb|JSONField|.

Django keeps track of the database systems' differences in the
\verb|django.db.backends| module. Each database system has its own database
backend submodule.\footnote{Except for MariaDB and MySQL, as they can share the
same driver and backend.} The database backends' classes are extended from the
classes in the \verb|django.db.backends.base| submodule. For example, the
\verb|DatabaseFeatures| class stores boolean flags and other feature-related
information as the class' attributes, and the default values for these
attributes are defined in the \verb|BaseDatabaseFeatures| class.

\listing
{Python}
{The new flags for \code{JSONField} in the \code{BaseDatabaseFeatures} class.}
{code:basedbfeatures}
{codes/4-basedbfeatures.py}

To implement the \verb|JSONField| class, three flags are added to the
\verb|BaseDatabaseFeatures| class. The first flag is
\verb|supports_json_field|, which shows whether the database system supports
\verb|JSONField|. The second flag is \verb|supports_primitives_in_json_field|,
which is used to determine whether the database system supports storing JSON
scalar values (strings, numbers, booleans, and \verb|null|) directly in a
\verb|JSONField|.\footnote{This flag is not used in the \code{JSONField}
implementation itself, but it is useful to store this information to be used in
tests.} The third flag is \verb|has_native_json_field|, which shows whether the
database system has a native JSON data type and the database driver
automatically deserializes JSON data into Python objects. These flags are
overridden in each database backend's \verb|DatabaseFeatures| class as
necessary.

\listing
[0 pt]
{Python}
{The \code{DatabaseWrapper} class of the PostgreSQL backend.}
{code:backends-postgresql-1}
{codes/4-backends-postgresql-1.py}

For the PostgreSQL database backend, the \verb|DatabaseWrapper| class is
modified to add support for \verb|JSONField|. The \verb|data_types| property of
the class is updated to map \verb|JSONField| to the \verb|jsonb| data type, as
shown by line 7 of the listing. The \verb|jsonb| data type automatically checks
whether the data is valid JSON, so there is no need for a \verb|CHECK|
constraint.

\listing
{Python}
{The \code{DatabaseFeatures} class of the PostgreSQL backend.}
{code:backends-postgresql-2}
{codes/4-backends-postgresql-2.py}

PostgreSQL has a native JSON data type and the driver (Psycopg 2) automatically
deserializes JSON data into Python objects. Thus, the
\verb|has_native_json_field| flag in the \verb|DatabaseFeatures| class of the
backend is set to \verb|True|, as shown by line 4 of
\autoref{code:backends-postgresql-2}. The other flags
(\verb|supports_json_field|\footnote{Django supports PostgreSQL 9.5 and higher,
while \code{jsonb} is available as of version 9.4, so \code{JSONField} is
always supported.} and \verb|supports_primitives_in_json_field|) are not
overridden, as their values from \verb|BaseDatabaseFeatures| are already
correct.

\listing
{Python}
{The \code{DatabaseOperations} class of the PostgreSQL backend.}
{code:backends-postgresql-3}
{codes/4-backends-postgresql-3.py}

To allow a custom decoder for \verb|JSONField| on PostgreSQL, Psycopg 2's
automatic deserialization of JSON data should be disabled. Disabling the
feature can be done by casting the data to \verb|text| or registering a stub
function for Psycopg 2's \verb|jsonb| converter
\cite{psycopg2:json-adaptation}. The casting option was chosen during this
research, as registering a stub function may break compatibility with the
previous implementation that relied on the automatic
deserialization.\footnote{The casting operation is efficient and does not
involve a copy, so this decision should not significantly affect the
performance of \code{JSONField} \cite{psycopg2:json-adaptation}.} The casting
operation is stored as a method in the \verb|DatabaseOperations| class of the
backend. In the case of PostgreSQL, casting data to \verb|text| can be done
using the \verb|::text| syntax, as shown by line 6 of
\autoref{code:backends-postgresql-3}.

\listing
{Python}
{The \code{DatabaseWrapper} class of the MySQL backend.}
{code:backends-mysql-1}
{codes/4-backends-mysql-1.py}

The MySQL database backend, which is used for MariaDB and MySQL, is modified to
add support for \verb|JSONField|. For this backend, the \verb|DatabaseWrapper|
class is modified by adding a mapping from \verb|JSONField| to the \verb|json|
data type in the \verb|data_types| property, as shown by line 6 of
\autoref{code:backends-mysql-1}. The \verb|data_type_check_constraints|
property method is also modified to add the \verb|JSON_VALID()| function as a
\verb|CHECK| constraint for MariaDB prior to version 10.4.3, as shown by lines
15 and 16 of the listing. Later versions of MariaDB have the \verb|CHECK|
constraint automatically enabled when using the \verb|JSON| data type alias,
while MySQL automatically validates the JSON syntax when using the \verb|JSON|
data type. Therefore, there is no need to modify
\verb|data_type_check_constraints| for these systems.

\listing
{Python}
{The \code{DatabaseFeatures} class of the MySQL backend.}
{code:backends-mysql-2}
{codes/4-backends-mysql-2.py}

Meanwhile, the \verb|DatabaseFeatures| class is modified by turning
\verb|supports_json_field| into a cached property method. The method returns
\verb|True| for MariaDB version 10.2.7 or greater and MySQL version 5.7.8 or
greater (and \verb|False| otherwise), as shown by lines 4 to 8 of
\autoref{code:backends-mysql-2}. The other flags
(\verb|supports_primitives_in_json_field| and \verb|has_native_json_field|)
use the values from \verb|BaseDatabaseFeatures| as they are already correct.

\listing
{Python}
{The \code{DatabaseWrapper} class of the SQLite backend.}
{code:backends-sqlite3-1}
{codes/4-backends-sqlite3-1.py}

The \verb|DatabaseWrapper| class of the SQLite backend is modified to add the
mapping from \verb|JSONField| to \verb|text| in the \verb|data_types| property,
as shown by line 7 of \autoref{code:backends-sqlite3-1}. It is also modified to
apply the \verb|JSON_VALID()| check constraint to the database column. As the
function returns \verb|0| (false) for SQL \verb|NULL| values, an
\verb|OR "%(column)s" IS NULL| clause is added to support storing SQL
\verb|NULL| values, as shown by line 12 of the listing.

\listing
{Python}
{The \code{DatabaseFeatures} class of the SQLite backend.}
{code:backends-sqlite3-2}
{codes/4-backends-sqlite3-2.py}

Meanwhile, \verb|DatabaseFeatures| class is modified to check for JSON support
on SQLite. The \verb|supports_json_field| flag is turned into a cached property
method and the value is determined by trying to execute a \verb|SELECT| query
with the \verb|JSON()| function included in the JSON1 extension, as shown by
lines 4 to 8 of \autoref{code:backends-sqlite3-2}. If the query does not throw
an exception, it means the JSON1 extension is enabled and the flag is set to
\verb|True| (and \verb|False| otherwise), as shown by lines 9 to 11 of the
listing. The support check is done this way because SQLite does not provide a
direct way to check whether the JSON1 extension is loaded. The other flags
(\verb|supports_primitives_in_json_field| and \verb|has_native_json_field|)
are derived from \verb|BaseDatabaseFeatures|.

\listing
{Python}
{The \code{DatabaseWrapper} class of the Oracle Database backend.}
{code:backends-oracle-1}
{codes/4-backends-oracle-1.py}

For the Oracle Database backend, the \verb|DatabaseWrapper| class is modified
to add the data type mapping and \verb|CHECK| constraint. The \verb|data_types|
property is updated to map \verb|JSONField| to \verb|NCLOB|, as shown by line 7
of \autoref{code:backends-oracle-1}. The \code{NCLOB} data type is chosen to
allow data larger than 32,767 bytes and to have Unicode support
\cite{oracle:overview-json, oracle:database-concepts}. The
\verb|data_type_check_constraints| property is also updated to apply the
\verb|IS JSON| constraint for \verb|JSONField|, as shown by line 12 of the
listing.

\listing
{Python}
{The \code{DatabaseOperations} class of the Oracle Database backend.}
{code:backends-oracle-2}
{codes/4-backends-oracle-2.py}

The cx\_Oracle database driver returns \verb|CLOB| and \verb|BLOB| values from
the database as \verb|LOB| objects in Python \cite{cxoracle:lob}. Meanwhile,
the \verb|LOB| objects need to be converted to Python strings in order to
perform deserialization. To do this, the \verb|get_db_converters()| method in
the \verb|DatabaseOperations| class is overridden so that \verb|JSONField| uses
the \verb|convert_textfield_value| converter, as shown by lines 7 and 8 of
\autoref{code:backends-oracle-2}.\footnote{\code{TextField} also uses the
\code{NCLOB} data type on Oracle Database, so its converter can be reused for
\code{JSONField}.}

\listing
{Python}
{The \code{DatabaseFeatures} class of the Oracle Database backend.}
{code:backends-oracle-3}
{codes/4-backends-oracle-3.py}

As for the \verb|DatabaseFeatures| class, the \verb|supports_primitives_in_json_field|
flag is overridden to \verb|False|, as shown by line 4 of
\autoref{code:backends-oracle-2}. This flag reflects the behavior of Oracle
Database that only allows storing JSON objects and arrays in a column with the
\verb|IS JSON| constraint enabled. The other flags
(\verb|supports_json_field|\footnote{Oracle Database introduced JSON support in
version 12.1.0.2 and Django supports Oracle Database version 12.2 and higher,
so \code{JSONField} is always supported.} and \verb|has_native_json_field|) are
derived from \verb|BaseDatabaseFeatures|.

All of the database backends have now been adjusted with the necessary changes.
The changes were mostly made for mapping \verb|JSONField| to the correct data
type on the database, as well as the \verb|CHECK| constraints to ensure that
the data is valid JSON. With these changes in place, the \verb|JSONField| class
can now be implemented.

%-----------------------------------------------------------------------------%
\section{\code{JSONField}}
%-----------------------------------------------------------------------------%

In the Django codebase, model fields are defined in the
\verb|django.db.models.fields| module as subclasses of \verb|Field|, but they
can be imported from the \verb|django.db.models| module for convenience. Model
fields that are relatively simple are implemented in the \verb|__init__.py|
file of the module. For model fields that require more complex implementation
(e.g. file fields and relational fields), they are defined in their own files
in the \verb|fields| directory. Due to the complexity of \verb|JSONField| and
its extended querying capabilities, the implementation is defined in the
\verb|json.py| file in the \verb|fields| directory.

\listing
{Python}
{The \code{deconstruct()} method of \code{Field}.}
{code:field-deconstruct}
{codes/4-field-deconstruct.py}

Model fields have a \verb|deconstruct| method that defines how the field can be
reconstructed from a database migration. The method returns a 4-tuple that
consists of: the name of the field on the model, the import path of the field,
a list of positional arguments, and a dictionary of keyword arguments
\cite{django:model_fields}. By convention, model fields that are defined in
their own files like \verb|JSONField| should still be imported from
\verb|django.db.models|. Thus, the \verb|deconstruct()| method of the
\verb|Field| class is modified to shorten the path for \verb|JSONField|'s
module, as shown by lines 15 to 17 of \autoref{code:field-deconstruct}.

\listing
{Python}
{The \code{check()} method of \code{JSONField} model field.}
{code:jsonfield-check}
{codes/4-jsonfield-check.py}

The \verb|JSONField| class implements some checks to make sure that it is
used correctly. In addition to the checks included from the \verb|Field| class,
\verb|JSONField| also extends the \verb|CheckFieldDefaultMixin| class, as shown
by line 1 of \autoref{code:jsonfield-check}. The mixin adds a check to ensure
that any default value set for the field should be a callable instead of an
instance, so that it's not shared between all instances of the field. The
\verb|JSONField| class also overrides the \verb|check()| method to include the
\verb|_check_supported()| method in the checking process, as shown by lines 4
to 8 of the listing.

\listing
{Python}
{The \code{\_check\_supported()} method of \code{JSONField} model field.}
{code:jsonfield-checksupported}
{codes/4-jsonfield-checksupported.py}

The \verb|_check_supported()| method checks all of the connected databases for
\verb|JSONField| support. If migrations for the model (that the field is
attached to) are not allowed on the database by the database router, then the
database is skipped from the check, as shown by lines 4 and 5 of
\autoref{code:jsonfield-checksupported}. Otherwise, the
\verb|supports_json_field| feature flag is checked. Lines 7 to 17 show that if
the flag's value is \verb|False| and the model is not explicitly defined to
require the feature flag, then a system error is added to the lists of errors
to be returned by the \verb|check| method and shown to the programmer.

\listing
{Python}
{The \code{get\_internal\_type()} method of \code{JSONField} model field.}
{code:jsonfield-getinternaltype}
{codes/4-jsonfield-getinternaltype.py}

To determine the key that is used to get the data type and check constraints
from the database backends, the \verb|get_internal_type()| method is used. By
default, the method returns the name of the class (using
\verb|self.__class__.__name__|), so it is not necessary to override it.
However, other model fields override the method to explicitly return the name
of the class, so that other classes may extend the model fields without having
to override the \verb|get_internal_type()| method unless it is needed. Thus,
the \verb|get_internal_type()| method is overridden to explicitly return the
string \verb|'JSONField'|, as shown by line 2 of
\autoref{code:jsonfield-getinternaltype}.

\listing
{Python}
{The \code{get\_prep\_value()} method of \code{JSONField} model field.}
{code:jsonfield-ser}
{codes/4-jsonfield-ser.py}

In the previous chapter, \verb|JSONField| is designed to serialize Python
objects into JSON-encoded strings by utilizing the built-in \verb|json| library
in Python. The serialization process is needed in order to store Python objects
as JSON in the database. To convert Python objects to query values, the
\verb|get_prep_value()| method should be overridden. The serialization is shown
by line 4 of \autoref{code:jsonfield-ser}, where the Python object is passed
to the \verb|json.dumps()| function, which also accepts an optional encoder
class as the \verb|cls| argument. Lines 2 and 3 of the listing show that the
\verb|None| value should not be serialized, because it is reserved for SQL
\verb|NULL| as previously explained.

\listing
{Python}
{The \code{value\_to\_string()} method of \code{JSONField} model field.}
{code:jsonfield-valuetostring}
{codes/4-jsonfield-valuetostring.py}

In addition to the serialization needed to store a Python object inside
\verb|JSONField| to the database, Django also has a serialization framework
that can be used for model objects. The framework can be used to dump model
objects into XML, JSON, and YAML files. The model objects are serialized by
calling the \verb|value_to_string()| method of their fields. Normally, the
method returns a string that is ready to be used by the serializer. However,
\verb|JSONField| represents JSON data in its Python built-in format that
can be serialized by the built-in serializers. Therefore, the method should
just return the Python object as-is and let the serializers handle the
serialization process. To achieve this, the \verb|value_to_string()| method
is overridden to just return the object using the \verb|value_from_object()|
method, as shown by line 2 of \autoref{code:jsonfield-valuetostring}.

\listing
{Python}
{The \code{from\_db\_value()} method of \code{JSONField} model field.}
{code:jsonfield-des}
{codes/4-jsonfield-des.py}

\verb|JSONField| is also designed to deserialize JSON-encoded strings to Python
objects in order to load the JSON data from the database. To convert database
values to Python objects, the \verb|from_db_value()| method can be overridden.
On some database systems that have a native JSON data type, the database driver
may already deserialize the value before Django receives it.\footnote{Only
PostgreSQL's Psycopg 2 driver does this at the time of writing, but this may
change in the future.} Lines 4 and 5 of \autoref{code:jsonfield-des} show that
the value is returned as-is, unless a custom decoder is used. In other cases,
the deserialization process is shown by line 7 of the listing, where
the database value is passed to the \verb|json.loads()| function, which also
accepts an optional decoder class as the \verb|cls| argument. Similar to
\verb|get_prep_value()|, the \verb|None| value is reserved for SQL \verb|NULL|,
as shown by lines 2 and 3 of the listing.

When extracting JSON string values, the database systems return them as
deserialized values (i.e. without JSON double quotes). Passing deserialized
strings to \verb|json.loads()| may cause \verb|json.JSONDecodeError| to be
raised. Therefore, as shown by lines 7 to 10 of \autoref{code:jsonfield-des},
the \verb|json.loads()| call is put inside a \verb|try ... except| block and
the value is directly returned if \verb|json.JSONDecodeError| is raised.

\listing
{Python}
{The \code{select\_format()} method of \code{JSONField}.}
{code:jsonfield-selectformat}
{codes/4-jsonfield-selectformat.py}

To cast JSON data to \verb|text| on the database level, the
\verb|select_format()| method is overridden in the \verb|JSONField| class. As
the name suggests, this method determines the format of the \verb|SELECT|
clause of the SQL query. The casting operation is needed in order to enable the
use of a custom decoder with a database system that automatically deserializes
JSON data into Python objects. Thus, the casting operation is performed only if
a custom decoder is used with a database backend that has the
\verb|has_native_json_field| feature flag set to \verb|True|, as shown by lines
2 to 6 of \autoref{code:jsonfield-selectformat}.

\listing
{Python}
{The \code{\_\_init\_\_()} method (constructor) of \code{JSONField}
model field.}
{code:jsonfield-init}
{codes/4-jsonfield-init.py}

The custom encoder and decoder are stored as instance attributes of the field,
as shown by lines 13 and 14 of \autoref{code:jsonfield-init}. It is important
to note that the encoder and decoder are subclasses of \verb|json.JSONEncoder|
and \verb|json.JSONDecoder|, rather than instances of those classes. In Python,
a class is a callable that returns an instance of the class, so the encoder and
decoder have to be callables. To enforce this requirement, the \verb|JSONField|
constructor checks whether the encoder and decoder are callables and raises
descriptive error messages if they are not, as shown by lines 5 to 12 of the
listing.

\listing
{Python}
{The \code{deconstruct()} method of \code{JSONField} model field.}
{code:jsonfield-dec}
{codes/4-jsonfield-dec.py}

In order to preserve the encoder and decoder classes in database migrations,
the \verb|deconstruct()| method needs to be overridden. The encoder and decoder
are defined as keyword arguments of the constructor. Therefore, the
\verb|deconstruct()| method is overridden to add the encoder and decoder
classes (if they are set, i.e. not \verb|None|) to the keyword arguments
dictionary, as shown by lines 3 to 6 of \autoref{code:jsonfield-dec}.

\listing
{Python}
{The \code{\_\_init\_\_()} method (constructor) of \code{JSONField} form field.}
{code:formfield-init}
{codes/4-formfield-init.py}

The \verb|JSONField| form field has also been updated to support custom encoder
and decoder. As with the model field, the encoder and decoder classes are
stored as instance attributes of the form field, as shown by lines 8 and 9 of
\autoref{code:formfield-init}. The encoder and decoder classes are used in
\verb|json.dumps()| and \verb|json.loads()| calls throughout the form field,
respectively.

\listing
{Python}
{The \code{prepare\_value()} and \code{has\_changed()} methods of
\code{JSONField} form field.}
{code:formfield-dumps}
{codes/4-formfield-dumps.py}

To utilize a custom encoder, some of the \verb|JSONField| form field methods
had to be updated. Line 4 of \autoref{code:formfield-dumps} shows the encoder
class used in the \verb|json.dumps()| call inside the \verb|prepare_value()|
method, which is used to prepare the value before it is shown to the user (e.g.
in an HTML form). Lines 12 and 13 show the encoder class used in the
\verb|json.dumps()| calls inside the \verb|has_changed()| method, which is used
to check whether the value inside the form field has changed.

\listing
{Python}
{The \code{to\_python()} and \code{bound\_data()} methods of \code{JSONField}
form field.}
{code:formfield-loads}
{codes/4-formfield-loads.py}

Some of the \verb|JSONField| form field methods also had to be updated to
support the use of a custom decoder. Line 4 of \autoref{code:formfield-loads}
shows the decoder class used in the \verb|json.loads()| call inside the
\verb|to_python()| method, which is used in the form field validation process.
If the value cannot be deserialized with the decoder, a \verb|ValidationError|
is raised, as shown by lines 5 to 10. Line 16 shows the decoder class used in
the \verb|json.loads()| call inside the \verb|bound_data()| method, which is
used to load the input data to the form field.

The form field only handles user input and does not interact with the database
directly. Thus, it is possible to use it with any database backend. As a
result, the form field has now been moved from the
\verb|django.contrib.postgres.forms| module to the \verb|django.forms| module.

\listing
{Python}
{The \code{formfield()} method of \code{JSONField} model field.}
{code:jsonfield-form}
{codes/4-jsonfield-form.py}

When model fields are included in a \verb|ModelForm|, Django automatically
generate form fields for them \cite{django:modelform}. The form fields are
generated by calling the \verb|formfield()| method of the model fields. In
order to use the encoder and decoder from the \verb|JSONField| model field in
the \verb|JSONField| form field, they need to be passed as keyword arguments,
as shown by lines 4 and 5 of \autoref{code:jsonfield-form}.

\listing
{Python}
{The \code{validate()} method of \code{JSONField} model field.}
{code:jsonfield-validate}
{codes/4-jsonfield-validate.py}

Model fields can define a built-in validation mechanism in the
\verb|validate()| method. The method is called by the field's \verb|clean()|
method as part of the model validation process of a \verb|ModelForm|. For
\verb|JSONField|, the \verb|validate()| method is overridden to provide a
basic validation mechanism by trying to serialize the field's value with the
given encoder, as shown by lines 3 and 4 of \autoref{code:jsonfield-validate}.
Lines 5 to 10 of the listing show that if the serialization fails, then a
\verb|ValidationError| is raised.

Now that the \verb|JSONField| class has been implemented, it is possible to
store and load JSON data to and from the database. As explained in the previous
chapter, there are also lookups and transforms that are specific for
\verb|JSONField|. The lookups and transforms extend the querying capabilities
for \verb|JSONField| by utilizing the functions and operators available on the
database systems. The implementation of the lookups and transforms will be
explained in the next section.

%-----------------------------------------------------------------------------%
\section{\code{JSONField} Lookups and Transforms}
%-----------------------------------------------------------------------------%

Lookups and transforms are part of Django's query expressions API. The API
consists of classes which instances can be compiled by Django's
\verb|SQLCompiler| objects. An \verb|SQLCompiler| object translates a query
expression by calling its \verb|as_vendorname()|\footnote{The \code{vendorname}
is the value of the \code{vendor} attribute in the \code{DatabaseWrapper} class
of the database backend, i.e. \code{postgresql}, \code{mysql}, \code{sqlite},
and \code{oracle}.} method (for vendor-specific implementation) if it exists,
and falls back to the \verb|as_sql()| method otherwise.

The lookups and transforms in this research are specific to \verb|JSONField|.
Normally, lookups and transforms are implemented in the
\verb|django.db.models.lookups| module. In the module, lookups are implemented
as subclasses of the \verb|Lookup| class, while transforms are implemented as
subclasses of the \verb|Transform| class. However, as the lookups and
transforms in this research are specific to \verb|JSONField|, they are
implemented as part of the \verb|django.db.models.fields.json| module.

The existing lookups for the PostgreSQL-only \verb|JSONField| serve as the
basis for the new implementation. The lookups are the containment lookups
(\verb|contains| and \verb|contained_by|), as well as the key existence
lookups (\verb|has_key|, \verb|has_keys|, and \verb|has_any_keys|). In addition
to that, the \verb|exact| lookup also has to be overridden in order to
support the JSON \verb|null| value.

The transforms are the key, index, and path transforms that extract the value
of JSON data at a given path. The index transform is just a special case of
the key transform where the key is an integer. Meanwhile, the path transform
can be viewed as a chain of key transforms. Therefore, the transforms are
unified as \verb|KeyTransform| in the existing implementation. The value
extracted by the transforms can be chained with some of the built-in lookups
and the \verb|JSONField|-specific lookups. As these transforms may return
values of different data types, some of the lookups also need to be modified
when they are used with on a \verb|KeyTransform|.

The lookups can be used directly on a \verb|JSONField| or on
\verb|KeyTransform|s applied to the field. When some of the lookups are used on
the transforms, they are implemented differently. Thus, before going in-depth
with the lookups implementation, it is better to go through the transforms
first.

\subsection{\code{JSONField} Transforms}

\listing
{Python}
{Parts of the \code{KeyTransform} class.}
{code:keytransform-1}
{codes/4-keytransform-1.py}

The key, index, and path
transforms are unified as the \verb|KeyTransform| class, which can be used to
extract the value of a \verb|JSONField| at a given path. The class includes the
{PostgreSQL} operators for extracting JSON values as shown by lines 2 and 3
of \autoref{code:keytransform-1}. Line 7 shows that the key name is normalized
as a string on initialization.

\listing
{Python}
{The \code{preprocess\_lhs()} method of the \code{KeyTransform} class.}
{code:keytransform-2}
{codes/4-keytransform-2.py}

To process a chain of \verb|KeyTransform|s that make up a path transform, the
\verb|preprocess_lhs()| method is created. Lines 4 to 8 of
\autoref{code:keytransform-2} show how the method separates the chain of
\verb|KeyTransform|s from the previous \verb|lhs|. The separation is done by
traversing the \verb|lhs| attribute of the \verb|KeyTransforms| until the
\verb|lhs| is not a \verb|KeyTransform|. While traversing, the key names that
construct the path are saved into a list. The method then compiles the original
\verb|lhs| and its parameters, and return them along with the list of
\verb|KeyTransforms|, as shown by lines 9 and 12. Lines 10 and 11 show that on
Oracle Database, any \verb|%| character in the key name is replaced by
\verb|%%| to escape string formatting (this will be explained later). In
addition, the method also has an \verb|lhs_only| parameter for optimization by
not saving and returning the key names if they are not needed, as shown by
lines 1, 2, 6, and 12.

\listing
{Python}
{The \code{as\_postgresql()} method of the \code{KeyTransform} class.}
{code:keytransform-3}
{codes/4-keytransform-3.py}

To compile a \verb|KeyTransform| into an SQL query expression, the
\verb|as_vendor()| method is used, e.g. \verb|as_postgresql()| for the
PostgreSQL backend. The method uses the \verb|preprocess_lhs()| method
described previously, as shown by line 2 of \autoref{code:keytransform-3}. If
there are multiple \verb|KeyTransform|s, the \verb|postgres_nested_operator|
(\verb|#>|) is used, as shown by lines 3 to 7 of the listing. Otherwise, the
\verb|postgres_operator| (\verb|->|) is used, as shown by lines 12 to 15. For
consistency, if there is only one \verb|KeyTransform| and the key is an
integer, it is assumed to be an array index by converting it to the \verb|int|
data type, as shown by line 9. The conversion is not needed for the nested
operator because for this operator, PostgreSQL automatically interprets integer
key names as array indices.

\listing
{Python}
{The \code{as\_sql()} method of the existing PostgreSQL-only \code{KeyTransform} class.}
{code:keytransform-0}
{codes/4-keytransform-0.py}

During this research, a security vulnerability was found in the existing
PostgreSQL-only implementation of \verb|KeyTransform|. Previously, the SQL
query expression was implemented in the \verb|as_sql()| method because it's
assumed that \verb|KeyTransform| is only used on PostgreSQL (as part of the
\verb|django.contrib.postgres| module). In the method, when there is only one
\verb|KeyTransform|, the key name is directly inserted into the string, rather
than passing it in the SQL parameters, as shown by lines 6, 8, and 9 of
\autoref{code:keytransform-0}. In addition, the key name is also not properly
quoted using \verb|json.dumps()|.

The approach in the existing implementation opened up a way for executing an
SQL injection by using a specially crafted string as the key name. The key name
is usually passed as a keyword argument in Python, which means that the string
can only contain alphanumeric characters and underscores. However, keyword
arguments can also be specified using a dictionary in Python, which allows any
string as a key name.

Using a malicious string as a key name in a dictionary that's passed as keyword
arguments, a user can execute an SQL injection. This vulnerability was reported
via email to the Django security team\footnote{Security issues in Django should
be reported to
\href{mailto:security@djangoproject.com}{security@djangoproject.com}, not the
public issue tracker.} and it was classified as CVE-2019-14234 \cite{cve} with
critical severity. To fix the vulnerability, a patch was issued for the Django
1.11, 2.1, and 2.2 releases \cite{django:securityrelease}. The implementation
of \verb|as_postgresql()| in this research has incorporated the patch, as shown
by lines 8 to 15 of \autoref{code:keytransform-3}.

\listing
{Python}
{The \code{compile\_json\_path()} function.}
{code:compilejsonpath}
{codes/4-compilejsonpath.py}

On other database systems, the JSON extraction functions use the JSONPath
notation to specify the path to be extracted. For reusability, the
\verb|compile_json_path()| function is created to convert a list of key names
into its JSONPath representation. The function works by iterating through the
list of key names and keeping a list of strings that make up the JSONPath. If
the key name is an integer, the string \verb|'[num]'| (where \verb|num| is the
integer) is appended to the list, as shown by lines 4, 5, 9, and 10 of
\autoref{code:compilejsonpath}. Otherwise, the key name is enclosed in double
quotes (so that it may contain spaces) by passing it through
\verb|json.dumps()|, as shown by lines 6 to 8. Additionally, the method also
has a \verb|include_root| parameter to control whether the resulting path
should include the root notation (\verb|$|), as shown by lines 1 and 2.
Finally, the list of strings is concatenated by joining the strings with an
empty string, as shown by line 11.

\listing
{Python}
{The \code{as\_mysql()} and \code{as\_sqlite()} methods of the \code{KeyTransform} class.}
{code:keytransform-4}
{codes/4-keytransform-4.py}

The \verb|as_vendor()| methods for MariaDB, MySQL, and SQLite are similar. The
methods utilize the \verb|preprocess_lhs()| method and
\verb|compile_json_path()| to construct the JSONPath notation of the key
transforms, as shown by lines 2, 3, 7, and 8 of \autoref{code:keytransform-4}.
To extract the value, the \verb|JSON_EXTRACT()| function is used, with
\verb|lhs| as the first argument and the JSONPath as the second argument, as
shown by lines 4 and 9.

\listing
{Python}
{The \code{as\_oracle()} method of the \code{KeyTransform} class.}
{code:keytransform-5}
{codes/4-keytransform-5.py}

Meanwhile, the \verb|as_oracle()| method needs some adjustments to work with
the behavior of Oracle Database. The method still uses the
\verb|preprocess_lhs()| method and \verb|compile_json_path()| function, as
shown by lines 2 and 3 of \autoref{code:keytransform-5}. However, to extract
the value, the \verb|JSON_QUERY()| and \verb|JSON_VALUE()| functions are
combined using the \verb|COALESCE()| function. This approach is needed as there
is no way to tell whether the value at the given path is a JSON object/array or
a scalar value. In addition, the path argument is added directly to the SQL
string, as shown by lines 5 and 6, because path expressions cannot be passed as
bind variables on Oracle Database \cite{oracle:jsonpath}.

\listing
{Python}
{Parts of the \code{Cast} class.}
{code:cast}
{codes/4-cast.py}

The JSON extraction functions are also useful for casting other fields to
\verb|JSONField| if the database system does not have a true data type for
JSON. To cast from one model field to another, Django provides the \verb|Cast|
class that can be used to perform casting on the database level. To support
casting to \verb|JSONField| on databases without a true data type for JSON, the
\verb|as_vendor()| methods of the \verb|Cast| class is overridden. The
\verb|JSON_EXTRACT()| function is used on MariaDB to force data to be
recognized as JSON, as shown by lines 6 to 8 of \autoref{code:cast}. Lines 14
to 16 show that on Oracle Database, the \verb|JSON_QUERY()| function is used.
For SQLite, using the \verb|JSON_EXTRACT()| function is not necessary as the
database can handle JSON data in its string form correctly.

\listing
{Python}
{The \code{KeyTextTransform} class.}
{code:keytexttransform}
{codes/4-keytexttransform.py}

Aside from \verb|KeyTransform|, the \verb|KeyTextTransform| class is also
implemented. The \verb|KeyTransform| class extracts JSON values with the
\verb|jsonb| data type on PostgreSQL. Meanwhile, some built-in lookups expect
the \verb|lhs| to be \verb|text|. Rather than casting the value to \verb|text|,
the \verb|KeyTextTransform| class works by using the \verb|->>| and \verb|#>>|
operators instead of the \verb|->| and \verb|#>| operators, as shown by lines 2
and 3 of \autoref{code:keytexttransform}. The \verb|as_vendor()| methods do not
need to be overridden for other database backends, because they already extract
JSON string values as \verb|text|.

\listing
{Python}
{The \code{KeyTransformFactory} class.}
{code:keytransformfactory}
{codes/4-keytransformfactory.py}

In order to use the transforms, a factory class (\verb|KeyTransformFactory|)
needs to be implemented. The key name of a \verb|KeyTransform| can be any
string as long as it doesn't clash with a registered lookup or transform.
Normally, transforms already have a predefined name for them, so their
\verb|__init__()| method does not have a parameter for defining the name. As
the key name of a \verb|KeyTransform| is defined dynamically, a factory class
is needed in order to encapsulate the key name information, as shown by line 4
of \autoref{code:keytransformfactory}. The key name will be passed as a
predefined argument when instantiating a \verb|KeyTransform| by calling the
factory object, as shown by lines 6 and 7 of the listing.

\listing
{Python}
{The \code{get\_transform()} method of the \code{JSONField} model field.}
{code:gettransform}
{codes/4-gettransform.py}

The factory instance is then registered to \verb|JSONField| by overriding the
\verb|get_transform()| method of \verb|JSONField| shown by
\autoref{code:gettransform}. The method works by trying to look recursively on
all parent classes for a registered transform with the given name and return it
if found, as shown by lines 2 to 4 of \autoref{code:gettransform}. If the
transform is not found, the method returns a \verb|KeyTransformFactory|
instance with the transform name as the key name, as shown by line 5 of the
listing.

As the transforms have been implemented, the lookups can now be implemented as
well. The lookups consist of the \verb|JSONField|-specific lookups and the
built-in lookups. The \verb|JSONField|-specific lookups are containment lookups
(\verb|contains| and \verb|contained_by|) and key existence lookups
(\verb|has_key|, \verb|has_keys|, and \verb|has_any_keys|). Meanwhile, the
built-in lookups are \verb|exact|, \verb|iexact|, \verb|isnull|,
\verb|icontains|, \verb|startswith|, \verb|istartswith|, \verb|endswith|,
\verb|iendswith|, \verb|regex|, \verb|iregex|, \verb|lt|, \verb|lte|,
\verb|gt|, and \verb|gte|.

\subsection{\code{JSONField} Lookups}

\listing
{Python}
{The \code{PostgresOperatorLookup} class.}
{code:pgop-lookup}
{codes/4-pgop-lookup.py}

In the existing PostgreSQL-only implementation, \verb|JSONField| lookups mostly
used a simple \verb|<lhs> <operator> <rhs>| format in the SQL queries sent to
the database (e.g. \verb|json_column @> '{"foo": "bar"}')|. To simplify the
implementation, a \code{PostgresSimpleLookup} class was created, so that the
lookups only needed to extend from the class and specify the operator. To
facilitate this research, the Django developers have moved this class from
\verb|django.contrib.postgres.lookups| to \verb|django.db.models.lookups| and
renamed the class to \verb|PostgresOperatorLookup|
\cite{gh-django:pgop-lookup}. By moving the class, the new implementation can
reuse the same logic without having to rely on the
\verb|django.contrib.postgres| module.

\listing
{Python}
{The new flags for the \code{JSONField} lookups in the \code{BaseDatabaseFeatures} class.}
{code:basedbfeatures2}
{codes/4-basedbfeatures2.py}

In addition to the database feature flags added to implement \verb|JSONField|,
there are some more of them added to implement the lookups, as shown by
\autoref{code:basedbfeatures2}. The first flag is \verb|has_json_operators|
that indicates whether the backend uses PostgreSQL-style JSON operators (e.g.
\verb|->|), which is set to \verb|False| and only overridden to \verb|True| for
PostgreSQL. The second flag is \verb|supports_json_field_contains| that
indicates whether the backend supports the containment lookups for
\verb|JSONField|. This flag is set to \verb|True| and overridden to
\verb|False| for SQLite and Oracle Database because they don't support the
containment lookups, as explained in the previous chapter. The last flag is the
\verb|json_key_contains_list_matching_requires_list| that indicates whether the
\verb|contains| lookup requires matching object structure. This flag is set
to \verb|False| and only overridden to \verb|True| for PostgreSQL as it is the
only system with the described behavior \cite{postgres:json}. Of the three
flags added above, the only flag used in the lookups implementation is
\verb|supports_json_field_contains|, while the others are only used in tests.

\listing
{Python}
{The \code{DataContains} class.}
{code:lookups-contains}
{codes/4-lookups-contains.py}

With the additional database feature flags added, the containment lookups can
now be implemented. One of the containment lookups is the \verb|contains|
lookup that matches JSON objects (\verb|lhs|) that contain the lookup value
(\verb|rhs|) as a subset. The lookup is implemented in the \verb|DataContains|
class shown by \autoref{code:lookups-contains}. On PostgreSQL, the lookup uses
the \verb|@>| operator, as shown by line 3 of the listing. On MariaDB and
MySQL, it uses the \verb|JSON_CONTAINS(lhs, rhs)| function, as shown by line
13. The lookup is not supported on other database backends, so the
\verb|NotSupportedError| is raised, as shown by lines 6 to 9.

\listing
{Python}
{The \code{ContainedBy} class.}
{code:lookups-contained_by}
{codes/4-lookups-contained_by.py}

The other containment lookup is the \verb|contained_by| lookup, implemented in
the \verb|ContainedBy| class shown by \autoref{code:lookups-contained_by}. The
lookup is the inverse of the \verb|contains| lookup, so it matches JSON objects
(\verb|lhs|) that are a subset of the lookup value (\verb|rhs|). The
implementation is similar to \verb|DataContains|, but the operator is changed
for PostgreSQL and the arguments switched for MariaDB and MySQL. On PostgreSQL,
the \verb|<@| is used. On MariaDB and MySQL, the \verb|JSON_CONTAINS(rhs, lhs)|
function is used, with the parameters switched, as shown by lines 13 and 14 of
the listing. As with \verb|DataContains|, the lookup is not supported by the
other database backends. With both of the lookups implemented, the containment
lookups are now complete.

The next set of lookups are the key existence lookups, which consist of the
\verb|has_key|, \verb|has_keys|, and \verb|has_any_keys| lookups. These
lookups have many similarities in their implementation. Thus, an abstraction
for these lookups are created as the \verb|HasKeyLookup| class.

\listing
{Python}
{The \code{as\_postgresql()} method of the \code{HasKeyLookup} class.}
{code:lookups-haskeylookup-1}
{codes/4-lookups-haskeylookup-1.py}

For PostgreSQL, the lookups make use of the \verb|?|, \verb|?&|, and \verb=?|=
operators, so the class extends from the \verb|PostgresOperatorLookup| class.
In the implementation of \verb|as_postgresql()|, the code also checks whether
the \verb|rhs| is a \verb|KeyTransform| rather than just a string. If so, then
the key names of the \verb|rhs| are retrieved and moved to the \verb|lhs|,
except the last one, as shown by lines 4 to 9 of
\autoref{code:lookups-haskeylookup-1}. After that, the \verb|rhs| is replaced
by the last key name, as shown by line 10. The adjustment is needed because
the key existence operators can only be used at the top-level of the data. To
check for keys at a certain depth, the \verb|lhs| needs to be extracted to
reach that depth in advance, so that the operators work on the extracted value.
Once the \verb|rhs| has been reduced to a single key, the method returns the
SQL expression produced by the \verb|PostgresOperatorLookup| class.

\listing
{Python}
{The \code{as\_sql()} method of the \code{HasKeyLookup} class.}
{code:lookups-haskeylookup-2}
{codes/4-lookups-haskeylookup-2.py}

For other database backends, they work similarly by using the JSONPath
notation. The JSONPath is used as the argument for the functions that check for
the existence of the JSONPath. To group the similarities found in the
\verb|as_vendor()| methods, the \verb|as_sql()| method is overridden, as shown
by \autoref{code:lookups-haskeylookup-2}.

The lookups can be used on a \verb|JSONField| or a \verb|KeyTransform|, so the
\verb|lhs| can be either of the two. If the \verb|lhs| is a
\verb|KeyTransform|, then all of the previous transforms are compiled into a
JSONPath, as shown by lines 6 to 10 of \autoref{code:lookups-haskeylookup-1}.
Otherwise, the \verb|lhs| is processed normally and the JSONPath is the root
(\verb|$|), as shown by lines 11 to 13.

The \verb|has_key| lookup accepts a key name (string) as the \verb|rhs|, but
the \verb|has_keys| and \verb|has_any_keys| lookup accepts a list or tuple of
key names. To unify the implementation, the \verb|rhs| is wrapped into a list
if it's not a list or tuple, as shown by lines 18 and 19 of
\autoref{code:lookups-haskeylookup-1}. Then, each key name in the \verb|rhs| is
compiled into a JSONPath that is prepended with the JSONPath from the lhs, as
shown by lines 20 to 30. After that, the JSONPaths are joined with a logical
operator defined by the class, as shown by lines 2 and 32 to 35. Finally, line
36 shows that the string result is returned along with the parameters.

\listing
{Python}
{The \code{as\_vendor()} methods of the \code{HasKeyLookup} class.}
{code:lookups-haskeylookup-3}
{codes/4-lookups-haskeylookup-3.py}

The differences between the database backends for \verb|HasKeyLookup| is
defined in the \verb|as_vendor()| methods. After the unification in
\verb|as_sql()| the \verb|as_vendor()| methods only need to define the
functions that are used on each database backend. MariaDB and MySQL use the
\verb|JSON_CONTAINS_PATH()| function, as shown by lines 1 to 4 of
\autoref{code:lookups-haskeylookup-3}. SQLite uses the \verb|JSON_TYPE()|
function with the \verb|IS NOT NULL| condition, as shown by lines 6 to 9.
Oracle Database uses the \verb|JSON_EXISTS()| function, as shown by lines 11 to
14. Additionally, the JSONPath needs to be added directly into the SQL
expression string, as shown by line 15, because it cannot be passed as bind
variables.

\listing
{Python}
{The \code{HasKey} class.}
{code:lookups-haskey}
{codes/4-lookups-haskey.py}

\listing
{Python}
{The \code{HasKeys} class.}
{code:lookups-haskeys}
{codes/4-lookups-haskeys.py}

\listing
{Python}
{The \code{HasAnyKeys} class.}
{code:lookups-hasanykeys}
{codes/4-lookups-hasanykeys.py}

After the \verb|HasKeyLookup| class is defined, the concrete classes for the
lookups only need to define the operators. The \verb|has_key| lookup is defined
in the \verb|HasKey| class and uses the \verb|?| PostgreSQL operator with no
logical operator for the other database backends, as shown by
\autoref{code:lookups-haskey}. The \verb|has_keys| lookup is defined in the
\verb|HasKeys| class and uses the \verb|?&| PostgreSQL operator and the
\verb|AND| logical operator for the other database backends, as shown by
\autoref{code:lookups-haskeys}. The \verb|has_any_keys| lookup is defined in
the \verb|HasAnyKeys| class and uses the \verb=?|= PostgreSQL operator and the
\verb|OR| logical operator for the other database backends, as shown by
\autoref{code:lookups-hasanykeys}.

In addition, the lookups need to prevent the \verb|rhs| from being serialized
into a JSON string because it would incorrectly add double quotes to the key
name. To do so, the \verb|prepare_rhs| flag is set to \verb|False| for the
\verb|HasKey| class. For the \verb|HasKeys| class, the \verb|rhs| is only
normalized (rather than serialized) as a list of strings by overriding the
\verb|get_prep_lookup()| method, as shown by lines 6 and 7 of
\autoref{code:lookups-haskeys}. The \verb|HasAnyKeys| class extends from the
\verb|HasKeys| lookup, so the overridden \verb|get_prep_lookup()| method is
inherited. As the concrete classes have been implemented, the key existence
lookups are now complete.

\listing
{Python}
{The \code{JSONExact} class.}
{code:lookups-jsonexact}
{codes/4-lookups-jsonexact.py}

Aside from the \verb|JSONField|-specific lookups, the \verb|exact| lookup also
needs to be modified in order to work with \verb|JSONField|. The lookup is
implemented in the \verb|JSONExact| class that extends \verb|lookups.Exact|, as
shown by line 1 of \autoref{code:lookups-jsonexact}. Line 2 shows that the
class has the \verb|can_use_none_as_rhs| flag set to \verb|True|. This override
prevents Django from automatically swapping the \verb|exact=None| lookup with
the \verb|isnull=True| lookup, which would turn the lookup into a query for SQL
\verb|NULL|. By disabling the automatic swapping, it is possible to query for
JSON \verb|null| value using \verb|exact=None|.

The \verb|process_lhs()| and \verb|process_rhs()| methods of the \verb|exact|
lookup are also overridden. The \verb|process_lhs()| is modified so that the
\verb|lhs| is wrapped with the \verb|JSON_TYPE()| function on SQLite if the
\verb|rhs| is \verb|None|, as shown by lines 6 to 9 of
\autoref{code:lookups-jsonexact}. On the other hand, the \verb|process_rhs()|
is modified by replacing \verb|None| with \verb|'null'| for all database
backends, as shown by lines 14 and 15. To make MariaDB and MySQL treat the
\verb|rhs| as a JSON value, the \verb|JSON_EXTRACT()| function is used, as
shown by lines 16 to 18.

\listing
{Python}
{The \code{field\_cast\_sql()} and \code{lookup\_cast()} methods of the
Oracle Database backend's \code{DatabaseOperations} class.}
{code:oracle-operations}
{codes/4-oracle-operations.py}

Once again, the \verb|DatabaseOperations| of the Oracle Database backend also
needs to be modified. As JSON data is stored using the \verb|NCLOB| data type,
directly including the value in the \verb|WHERE| clause of an SQL query is not
supported \cite{oracle:comparison}. To work around this limitation, the LOB
object is read using the \verb|DBMS_LOB.SUBSTR()| function, as shown by lines 8
and 9 of \autoref{code:oracle-operations}. To avoid unnecessary calls to
\verb|DBMS_LOB.SUBSTR()| in other situations, an additional check is added to
the \verb|field_cast_sql()| method, as shown by line 2. After applying these
modifications to the backend and the lookup class, the \verb|exact| lookup is
now compatible with \verb|JSONField|.

\listing
{Python}
{The registration of \code{JSONField} lookups.}
{code:register-jsonfield}
{codes/4-register-jsonfield.py}

Before custom lookups can be used on a model field, they need to be registered
using the \verb|register_lookup()| method of the field. The customized lookups
for \verb|JSONField| are the containment lookups, the key existence lookups,
and the \verb|exact| lookup. Therefore, the \verb|DataContains|,
\verb|ContainedBy|, \verb|HasKey|, \verb|HasKeys|, \verb|HasAnyKeys|, and
\verb|JSONExact| classes are registered on \verb|JSONField|, as shown by
\autoref{code:register-jsonfield}. After registering the lookups, they can now
be used on \verb|JSONField|. However, these lookups and other built-in lookups
still need to be modified in order to be used on \verb|KeyTransform|s, as
explained in the next subsection.

\subsection{\code{KeyTransform} Lookups}

The \verb|KeyTransform| class can be chained with \verb|JSONField|-specific
lookups and other built-in lookups. The \verb|KeyTransform| class works by
extracting the value of some JSON data at a given path. The extracted value
may be of any type: boolean, number, string, object, array, or \verb|null|.
In addition, the path may also be nonexistent. To implement the lookups on
\verb|KeyTransform|s, the different possibilities of the extracted value must
be taken into account.

\listing
{Python}
{The \code{process\_lhs()} method of \code{KeyTransformExact}.}
{code:lookups-keytransformexact-1}
{codes/4-lookups-keytransformexact-1.py}

One of the lookups that needs to be modified is the \verb|exact| lookup. The
lookup is implemented in the \verb|KeyTransformExact| class that extends
\verb|JSONExact|. As with \verb|JSONExact|, the \verb|process_lhs()| method is
overridden to wrap the \verb|lhs| with the \verb|JSON_TYPE()| function when
querying JSON \verb|null| value, as shown by line 10 of
\autoref{code:lookups-keytransformexact-1}. However, as the \verb|rhs_params|
are retrieved from the \verb|process_rhs()| of \verb|JSONExact|, the value has
changed from \verb|[None]| to \verb|['null']|, as shown by line 6. In addition,
the \verb|preprocess_lhs()| method is used to retrieve the original \verb|lhs|
before the \verb|KeyTransform|s are applied, as shown by lines 7 to 9 of the
listing.

\listing
{Python}
{The \code{process\_rhs()} method of \code{KeyTransformExact}.}
{code:lookups-keytransformexact-2}
{codes/4-lookups-keytransformexact-2.py}

The \verb|process_rhs()| method of \verb|KeyTransformExact| also needs to be
overridden. The \verb|rhs| of \verb|KeyTransformExact| can also be a
\verb|KeyTransform| expression, in which case the \verb|process_rhs()| of the
built-in \verb|exact| lookup is used, as shown by
\autoref{code:lookups-keytransformexact-2}. In other cases, the \verb|rhs|
needs to be wrapped in a JSON extraction function to be treated as JSON. On
Oracle Database, each value of the \verb|rhs_params| is wrapped inside a JSON
object at the key \verb|value|, as shown by lines 13 to 16. If the value is a
JSON object or array, the \verb|JSON_QUERY()| function is used. Otherwise, the
\verb|JSON_VALUE()| function is used, as shown by lines 9 to 12. Meanwhile on
SQLite, the \verb|JSON_EXTRACT()| function is used (unless the value is
\verb|null|), as shown by lines 19 to 24.

\listing
{Python}
{The \code{as\_oracle()} method of \code{KeyTransformExact}.}
{code:lookups-keytransformexact-3}
{codes/4-lookups-keytransformexact-3.py}

In addition, the \verb|as_oracle()| method of \verb|KeyTransformExact| is also
overridden to work with the JSON \verb|null| value. On Oracle Database,
querying for the JSON \verb|null| value works by checking that the key exists
and that the value (when extracted) is \verb|NULL|. The checks are implemented
by combining the \verb|has_key| lookup and the \verb|isnull| lookup, as shown
by \autoref{code:lookups-keytransformexact-3}.

\listing
{Python}
{The \code{KeyTransformIsNull} class.}
{code:lookups-keytransformisnull}
{codes/4-lookups-keytransformisnull.py}

The next lookup to be modified is the \verb|isnull| lookup, which is
implemented in the \verb|KeyTransformIsNull| class. When used on a
\verb|KeyTransform|, the \verb|isnull=True| lookup matches objects that do not
have the path specified by the \verb|KeyTransform|s, and vice versa. On
PostgreSQL, MariaDB, and MySQL, the JSON extraction functions used in
\verb|KeyTransform| already return the correct result for the \verb|isnull|
lookup. However, on SQLite and Oracle Database, the JSON extraction functions
return SQL \verb|NULL| when extracting JSON \verb|null|. The behavior affects
the \verb|isnull=False| lookup as it doesn't match objects where the path
exists but the value is \verb|null|. This issue can be fixed by replacing the
\verb|isnull=False| lookup with a \verb|HasKey| lookup performed on the
\verb|lhs|, as shown by lines 3, 4, 8, and 9 of
\autoref{code:lookups-keytransformisnull}.

The remaining lookups for \verb|KeyTransform| can be divided into two groups:
the text lookups and the numeric lookups. The text lookups are the
\verb|iexact|, \verb|icontains|, \verb|startswith|, \verb|istartswith|,
\verb|endswith|, \verb|iendswith|, \verb|regex|, and \verb|iregex| lookups. The
text lookups that start with \verb|i| are case-insensitive. Meanwhile, the
numeric lookups are the \verb|lt|, \verb|lte|, \verb|gt|, and \verb|gte|
lookups.

To use the built-in text lookups, the \verb|lhs| needs to be in the form of an
SQL string. On PostgreSQL, JSON values can be extracted as \verb|text| (rather
than \verb|jsonb|) using the \verb|->>| and \verb|#>>| operators, which have
been implemented in the \verb|KeyTransformText| class. On MariaDB and MySQL,
after using the \verb|JSON_EXTRACT()| function to extract the value, JSON
strings need to be unquoted using the \verb|JSON_UNQUOTE| function. On SQLite,
the \verb|JSON_EXTRACT()| function automatically unquotes JSON strings, so no
modification is needed. On Oracle Database, the \verb|JSON_VALUE()| function
also automatically unquotes JSON strings, so there is no modification needed as
well.

\listing
{Python}
{The \code{KeyTransformTextLookupMixin} class.}
{code:mixins-keytransformtextlookup}
{codes/4-mixins-keytransformtextlookup.py}

In order to use \verb|KeyTransformText| for lookups that expect the \verb|lhs|
as \verb|text|, the \verb|KeyTransformTextLookupMixin| class is created. The
mixin works by replacing the \verb|KeyTransform| with a \verb|KeyTextTransform|
in the \verb|__init__()| method, as shown by lines 8 to 12 of
\autoref{code:mixins-keytransformtextlookup}. If the class is instantiated with
a transform other than a \verb|KeyTransform|, a \verb|TypeError| is raised, as
shown by lines 3 to 7.

\listing
{Python}
{The \code{lookup\_cast()} method in the MySQL backend's
\code{DatabaseOperations} class.}
{code:mysql-operations}
{codes/4-mysql-operations.py}

To utilize the \verb|JSON_UNQUOTE()| function when performing lookups that
expect a string \verb|lhs| on MariaDB and MySQL, the \verb|DatabaseOperations|
class of the MySQL backend is modified by overriding the \verb|lookup_cast()|
method. If the \verb|lookup_type| argument of the method is one of the text
lookups and it is performed on a \verb|JSONField|, the method returns the
\verb|JSON_UNQUOTE()| function to be interpolated, as shown by lines 3 to 8 of
\autoref{code:mysql-operations}. In addition, as MariaDB does not have a native
JSON data type, it may require the \verb|JSON_UNQUOTE()| function regardless of
the lookup. Thus, the condition for MariaDB is added accordingly.

\listing
{Python}
{The \code{CaseInsensitiveMixin} class.}
{code:mixins-caseinsensitivemixin}
{codes/4-mixins-caseinsensitivemixin.py}

The text lookups also include case-insensitive lookups, but comparison of JSON
strings on MariaDB and MySQL is case-sensitive by default.\footnote{MariaDB and
MySQL handle strings in JSON context using the \code{utf8mb4\_bin} collation,
which is case sensitive.} To allow case-insensitive comparison of JSON values
on MariaDB and MySQL, the \verb|CaseInsensitiveMixin| class is created. The
mixin works by converting the \verb|lhs| and \verb|rhs| to lowercase using the
\verb|LOWER()| function, as shown by
\autoref{code:mixins-caseinsensitivemixin}.

\listing
{Python}
{The text lookup classes for \code{KeyTransform}.}
{code:lookups-keytransformtext}
{codes/4-lookups-keytransformtext.py}

With the necessary mixins created and the backend modification applied, the
text lookups for \verb|KeyTransform| can be implemented. The lookups are
implemented by extending the mixins and the built-in lookups accordingly, as
shown by \autoref{code:lookups-keytransformtext}. All of the lookup classes
extend the \verb|KeyTransformTextLookupMixin| class and their respective
built-in lookups. For case-insensitive lookups, the classes also extend the
\verb|CaseInsensitiveMixin| class. There are no methods or attributes to be
overridden, as Python automatically resolve any nonexistent properties to the
superclasses using its multiple inheritance logic.

\listing
{Python}
{The \code{KeyTransformNumericLookupMixin} class.}
{code:mixins-keytransformnumeric}
{codes/4-mixins-keytransformnumeric.py}

The remaining lookups for \verb|KeyTransform| are the numeric lookups, which
may or may not require the \verb|rhs| to be in a numeric type. To implement
the lookups, the \verb|KeyTransformNumericLookupMixin| class is created. For
database systems that have a native JSON data type, the \verb|rhs| should be
passed in its serialized form, so there is no modification needed. For other
database systems, the \verb|rhs| should be in a numeric (deserialized) type.
The mixin works by conditionally deserializing the rhs using the
\verb|json.loads()| function, as shown by
\autoref{code:mixins-keytransformnumeric}.

\listing
{Python}
{The numeric lookup classes for \code{KeyTransform}.}
{code:lookups-keytransformnumeric}
{codes/4-lookups-keytransformnumeric.py}

As with the text lookups, the numeric lookups can be implemented by extending
the mixins and built-in lookups. All of the numeric lookups extend from the
\verb|KeyTransformNumericLookupMixin| to ensure the \verb|rhs| is correct.
After that, the classes can just extend from the built-in lookups without
having to override any properties, as shown by
\autoref{code:lookups-keytransformnumeric}.

\listing
{Python}
{The registration of \code{KeyTransform} lookups.}
{code:register-keytransform}
{codes/4-register-keytransform.py}

With all of the necessary classes implemented, the lookups are now compatible
with \verb|KeyTransform|s. As with the \verb|JSONField| lookups, they need to
be registered on \verb|KeyTransform|. \autoref{code:register-keytransform}
shows that all of the lookups are registered to \verb|KeyTransform| using the
\verb|register_lookup()| method. The \verb|JSONField|-specific lookups can be
used without explicitly registering them to \verb|KeyTransform|, because
the output field of \verb|KeyTransform| is also \verb|JSONField|.
