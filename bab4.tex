%-----------------------------------------------------------------------------%
\chapter{\babEmpat}
%-----------------------------------------------------------------------------%

This chapter explains the implementation of \code{JSONField} and
\code{JSONField}-specific lookups and transforms that can be used on all
database backends supported by Django.

%-----------------------------------------------------------------------------%
\section{\code{JSONField}}
%-----------------------------------------------------------------------------%

Before we implement the \verb|JSONField| class, it is important to remember
that each database system requires a certain minimum version to be compatible
with \verb|JSONField|. The database systems also have different behaviors when
handling JSON data. For example, the PostgreSQL database driver automatically
deserializes JSON data as a Python object, while other database drivers return
it as a JSON-encoded string.

The database systems' different features and behaviors are tracked by Django
in the \verb|DatabaseFeatures| class of each database backend. The
\verb|DatabaseFeatures| class stores boolean flags and other feature-related
information as the class' attributes. Default values for these attributes are
defined in the \verb|BaseDatabaseFeatures| class.

\listing
{Python}
{The three additional flags in the \code{BaseDatabaseFeatures} class.}
{code:basedbfeatures}
{codes/4-basedbfeatures.py}

To implement the \verb|JSONField| class, three flags are added to the the
\verb|BaseDatabaseFeatures| class. The first flag is
\verb|supports_json_field|, which shows whether the database system supports
\verb|JSONField| or not. The second flag is
\verb|supports_primitives_in_json_field|, which is used to determine whether
the database system supports storing JSON scalar values (strings, numbers,
booleans, and \verb|null|) directly in a \verb|JSONField|. The third flag is
\verb|has_native_json_field|, which shows whether the database system has a
native JSON data type and automatically deserializes JSON data as Python
objects.

\listing
{Python}
{The \code{DatabaseFeatures} class of the MySQL backend.}
{code:dbfeatures-mysql}
{codes/4-dbfeatures-mysql.py}

The new feature flags are overridden in each database backend's
\verb|DatabaseFeatures| class as necessary. For the MySQL backend, which is
used by MariaDB and MySQL, the \verb|supports_json_property| is turned into a
cached property method. The method returns true for MariaDB version 10.2.7 or
greater and MySQL version 5.7.8 or greater, as shown by lines 4 to 8 of
\autoref{code:dbfeatures}.

\listing
{Python}
{The \code{DatabaseFeatures} class of the Oracle Database backend.}
{code:dbfeatures-oracle}
{codes/4-dbfeatures-oracle.py}

For the Oracle Database backend, the
\verb|supports_primitives_in_json_field| flag is overridden to \verb|False|
as shown by line 13 of \autoref{code:dbfeatures-oracle}. Oracle Database supports JSON data as of
version 12.1.0.2. Django supports Oracle Database version 12.2 and higher,
which means that JSON support is always available.

\listing
{Python}
{The \code{DatabaseFeatures} class of the PostgreSQL backend.}
{code:dbfeatures-postgresql}
{codes/4-dbfeatures-postgresql.py}

\listing
{Python}
{The \code{DatabaseFeatures} class of the SQLite backend.}
{code:dbfeatures-sqlite3}
{codes/4-dbfeatures-sqlite3.py}

For the PostgreSQL backend, the \verb|has_native_json_field| is set to \verb|True|, as
shown by line 18 of the listing. For the SQLite backend,
\verb|supports_json_field| is determined by trying to execute a \verb|SELECT|
query with the \verb|JSON()| function included in the JSON1 extension. If the
query does not throw an exception, it means the JSON1 extension is enabled and
the flag is set to \verb|True| (and \verb|False| otherwise), as shown by lines
23 to 30 of the listing. The support check is done this way because SQLite does
not provide a direct way to check whether the JSON1 extension is loaded.

In the Django codebase, model fields are defined in the
\verb|django.db.models.fields| module as subclasses of \verb|Field|, but they
can be imported from the \verb|django.db.models| module for simplicity. Model
fields that are relatively simple are implemented in the \verb|__init__.py|
file of the module. For model fields that require more complex implementation
(e.g. file fields and relational fields), they are defined in their own files
in the \verb|fields| directory. Due to the complexity of \verb|JSONField| and
its extended querying capabilities, the implementation is defined in the
\verb|json.py| file in the \verb|fields| directory.

As explained in the previous chapter, \verb|JSONField| requires a certain
minimum version for each database system.

\listing
{Python}
{The \code{get\_prep\_value()} method of \code{JSONField} model field.}
{code:jsonfield-ser}
{codes/4-jsonfield-ser.py}

In the previous chapter, \verb|JSONField| is designed to serialize Python
objects into JSON-encoded strings by utilizing the built-in \verb|json| library
in Python. The serialization process is needed in order to store Python objects
as JSON in the database. To convert Python objects to query values, the
\verb|get_prep_value()| method should be overridden. The serialization is shown
by line 7 of \autoref{code:jsonfield-ser}, where the Python object is passed
to the \verb|json.dumps()| function, which also accepts an optional encoder
class as the \verb|cls| argument. Lines 5 and 6 of the listing show that the
\verb|None| value should not be serialized, because it is reserved for SQL
\verb|NULL| as previously explained.

\listing
[0 pt]
{Python}
{The \code{from\_db\_value()} method of \code{JSONField} model field.}
{code:jsonfield-des}
{codes/4-jsonfield-des.py}

\verb|JSONField| is also designed to deserialize JSON-encoded strings to Python
objects in order to load the JSON data from the database. To convert database
values to Python objects, the \verb|from_db_value()| method can be overridden.
On some database systems that have a native JSON data type, the database driver
may already deserialize the value before Django receives it.\footnote{Only
PostgreSQL's Psycopg 2 driver does this at the time of writing, but this may
change in the future.} Line 7 and 8 of \autoref{code:jsonfield-des} show that
the value is returned as-is, unless a custom decoder is used. On other database
systems, the deserialization process is shown by line 10 of the listing, where
the database value is passed to the \verb|json.loads()| function, which also
accepts an optional decoder class as the \verb|cls| argument. Similar to
\verb|get_prep_value()|, the \verb|None| value is reserved for SQL \verb|NULL|,
as shown by lines 5 and 6 of the listing.

When extracting JSON string values, the database systems return them as
deserialized values (i.e. without JSON double quotes). Passing deserialized
strings to \verb|json.loads()| may cause \verb|json.JSONDecodeError| to be
raised. Therefore, as shown by lines 7 to 10 of \autoref{code:jsonfield-des},
the \verb|json.loads()| call is put inside a \verb|try ... except| block and
the value is directly returned if \verb|json.JSONDecodeError| is raised.

To allow a custom decoder for \verb|JSONField| on PostgreSQL, Psycopg 2's
automatic deserialization of JSON data should be disabled. Disabling the
feature can be done by casting the data to \verb|TEXT| or registering a stub
function for Psycopg 2's JSONB converter \cite{psycopg2:json-adaptation}.
The casting option was chosen during this research, as registering a stub
function may break compatibility with the previous implementation that
relied on the automatic deserialization. As noted on the Psycopg 2
documentation, the casting operation is efficient and does not involve a copy.

\listing
[0 pt]
{Python}
{The \code{select\_format()} method of \code{JSONField}.}
{code:selectformat}
{codes/4-selectformat.py}

\listing
{Python}
{The \code{json\_cast\_text\_sql()} method of the \code{DatabaseOperations}
class in Django's PostgreSQL database backend.}
{code:pgops}
{codes/4-pgops.py}

To cast JSON data to \verb|TEXT| on the database level, the
\verb|select_format()| method is overridden in the \verb|JSONField| class. As
the name suggests, this method determines the format of the \verb|SELECT|
clause of the SQL query. The casting is done only if a custom decoder is used
with a database backend that has a native JSON data type (and automatically
deserializes it), as shown by lines 5 to 9 of \autoref{code:selectformat}.
In the case of PostgreSQL, casting data to \verb|TEXT| can be done using the
\verb|::text| syntax, as shown by \autoref{code:pgops}.

\listing
{Python}
{The \code{\_\_init\_\_()} method (constructor) of \code{JSONField}
model field.}
{code:jsonfield-init}
{codes/4-jsonfield-init.py}

The custom encoder and decoder are stored as instance attributes of the field,
as shown by lines 16 and 17 of \autoref{code:jsonfield-init}. It is important
to note that the encoder and decoder are subclasses of \verb|json.JSONEncoder|
and \verb|json.JSONDecoder|, rather than instances of those classes. In Python,
a class is a callable that returns an instance of the class, so the encoder and
decoder have to be callables. To enforce this requirement, the \verb|JSONField|
constructor checks whether the encoder and decoder are callables and raises
descriptive error messages if they are not, as shown by lines 8 to 15 of the
listing.

\listing
{Python}
{The \code{deconstruct()} method of \code{JSONField} model field.}
{code:jsonfield-dec}
{codes/4-jsonfield-dec.py}

In order to preserve the encoder and decoder classes in database migrations,
the \verb|deconstruct()| method needs to be overridden. The method returns a
4-tuple that consists of: the name of the field on the model, the import path
of the field, a list of positional arguments, and a dictionary of keyword
arguments \cite{django:model_fields}. These values will be used to reconstruct
the field from a database migration. The encoder and decoder are defined as
keyword arguments of the constructor. Therefore, the \verb|deconstruct()|
method is overridden to add the encoder and decoder classes (if they are set,
i.e. not \verb|None|) to the keyword arguments dictionary, as shown by lines 6
to 9 of \autoref{code:jsonfield-dec}.

\listing
{Python}
{The \code{\_\_init\_\_()} method (constructor) of \code{JSONField} form field.}
{code:formfield-init}
{codes/4-formfield-init.py}

The \verb|JSONField| form field has also been updated to support custom encoder
and decoder. As with the model field, the encoder and decoder classes are
stored as instance attributes of the form field, as shown by lines 8 and 9 of
\autoref{code:formfield-init}. The encoder and decoder classes are used in
\verb|json.dumps()| and \verb|json.loads()| calls throughout the form field,
respectively.

\listing
{Python}
{The \code{prepare\_value()} and \code{has\_changed()} methods of
\code{JSONField} form field.}
{code:formfield-dumps}
{codes/4-formfield-dumps.py}

To utilize a custom encoder, some of the \verb|JSONField| form field methods
had to be updated. Line 7 of \autoref{code:formfield-dumps} shows the encoder
class used in the \verb|json.dumps()| call inside the \verb|prepare_value()|
method, which is used to prepare the value before it is shown to the user (e.g.
in an HTML form). Lines 15 and 16 show the encoder class used in the
\verb|json.dumps()| calls inside the \verb|has_changed()| method, which is used
to check whether the value inside the form field has changed.

\listing
{Python}
{The \code{to\_python()} and \code{bound\_data()} methods of \code{JSONField}
form field.}
{code:formfield-loads}
{codes/4-formfield-loads.py}

Some of the \verb|JSONField| form field methods also had to be updated to
support the use of a custom decoder. Line 18 of \autoref{code:formfield-loads}
shows the decoder class used in the \verb|json.loads()| call inside the
\verb|to_python()| method, which is used in the form field validation process.
If the value cannot be deserialized with the decoder, a \verb|ValidationError|
is raised, as shown by lines 20 to 24. Line 34 shows the decoder class used in
the \verb|json.loads()| call inside the \verb|bound_data()| method, which is
used to load the input data to the form field.

The form field only handles user input and does not interact with the database
directly. Thus, it is possible to use it with any database backend. As a
result, the form field has now been moved from the
\verb|django.contrib.postgres.forms| module to the \verb|django.forms| module.

\listing
{Python}
{The \code{formfield()} method of \code{JSONField} model field.}
{code:jsonfield-form}
{codes/4-jsonfield-form.py}

When model fields are included in a \verb|ModelForm|, Django automatically
generate form fields for them \cite{django:modelform}. The form fields are
generated by calling the \verb|formfield()| method of the model fields. In
order to use the encoder and decoder from the \verb|JSONField| model field in
the \verb|JSONField| form field, they need to be passed as keyword arguments,
as shown by lines 7 and 8 of \autoref{code:jsonfield-form}.
