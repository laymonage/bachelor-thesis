%-----------------------------------------------------------------------------%
\chapter{\babEmpat}
%-----------------------------------------------------------------------------%

This chapter explains the implementation of \code{JSONField} and
\code{JSONField}-specific lookups and transforms that can be used on all
database backends supported by Django.

%-----------------------------------------------------------------------------%
\section{Database Backend Adjustments}
%-----------------------------------------------------------------------------%

Before implementing the \verb|JSONField| class, it is important to remember
that there are differences between the database systems in regards to handling
JSON data. For example, each database system uses a different data type to
store JSON data. In addition, the database driver (e.g. Psycopg 2 for
PostgreSQL) may automatically deserialize JSON data into Python objects. These
differences need to be taken into account when implementing \verb|JSONField|.

Django keeps track of the database systems' differences in the
\verb|django.db.backends| module. Each database system has its own database
backend submodule.\footnote{Except for MariaDB and MySQL, as they can share the
same driver and backend.} The database backends' classes are extended from the
classes in the \verb|django.db.backends.base| submodule. For example, the
\verb|DatabaseFeatures| class stores boolean flags and other feature-related
information as the class' attributes, and the default values for these
attributes are defined in the \verb|BaseDatabaseFeatures| class.

\listing
{Python}
{The new flags for \code{JSONField} in the \code{BaseDatabaseFeatures} class.}
{code:basedbfeatures}
{codes/4-basedbfeatures.py}

To implement the \verb|JSONField| class, three flags are added to the
\verb|BaseDatabaseFeatures| class. The first flag is
\verb|supports_json_field|, which shows whether the database system supports
\verb|JSONField|. The second flag is \verb|supports_primitives_in_json_field|,
which is used to determine whether the database system supports storing JSON
scalar values (strings, numbers, booleans, and \verb|null|) directly in a
\verb|JSONField|.\footnote{This flag is not used in the \code{JSONField}
implementation itself, but it is useful to store this information to be used in
tests.} The third flag is \verb|has_native_json_field|, which shows whether the
database system has a native JSON data type and the database driver
automatically deserializes JSON data into Python objects. These flags are
overridden in each database backend's \verb|DatabaseFeatures| class as
necessary.

\listing
[0 pt]
{Python}
{The \code{DatabaseWrapper} class of the PostgreSQL backend.}
{code:backends-postgresql-1}
{codes/4-backends-postgresql-1.py}

For the PostgreSQL database backend, the \verb|DatabaseWrapper| class is
modified to add support for \verb|JSONField|. The \verb|data_types| property of
the class is updated to map \verb|JSONField| to the \verb|jsonb| data type, as
shown by line 7 of the listing. The \verb|jsonb| data type automatically checks
whether the data is valid JSON, so there is no need for a \verb|CHECK|
constraint.

\listing
{Python}
{The \code{DatabaseFeatures} class of the PostgreSQL backend.}
{code:backends-postgresql-2}
{codes/4-backends-postgresql-2.py}

PostgreSQL has a native JSON data type and the driver (Psycopg 2) automatically
deserializes JSON data into Python objects. Thus, the
\verb|has_native_json_field| flag in the \verb|DatabaseFeatures| class of the
backend is set to \verb|True|, as shown by line 4 of
\autoref{code:backends-postgresql-2}. The other flags
(\verb|supports_json_field|\footnote{Django supports PostgreSQL 9.5 and higher,
while \code{jsonb} is available as of version 9.4, so \code{JSONField} is
always supported.} and \verb|supports_primitives_in_json_field|) are not
overridden, as their values from \verb|BaseDatabaseFeatures| are already
correct.

\listing
{Python}
{The \code{DatabaseOperations} class of the PostgreSQL backend.}
{code:backends-postgresql-3}
{codes/4-backends-postgresql-3.py}

To allow a custom decoder for \verb|JSONField| on PostgreSQL, Psycopg 2's
automatic deserialization of JSON data should be disabled. Disabling the
feature can be done by casting the data to \verb|text| or registering a stub
function for Psycopg 2's \verb|jsonb| converter
\cite{psycopg2:json-adaptation}. The casting option was chosen during this
research, as registering a stub function may break compatibility with the
previous implementation that relied on the automatic
deserialization.\footnote{The casting operation is efficient and does not
involve a copy, so this decision should not significantly affect the
performance of \code{JSONField} \cite{psycopg2:json-adaptation}.} The casting
operation is stored as a method in the \verb|DatabaseOperations| class of the
backend. In the case of PostgreSQL, casting data to \verb|text| can be done
using the \verb|::text| syntax, as shown by line 6 of
\autoref{code:backends-postgresql-3}.

\listing
{Python}
{The \code{DatabaseWrapper} class of the MySQL backend.}
{code:backends-mysql-1}
{codes/4-backends-mysql-1.py}

The MySQL database backend, which is used for MariaDB and MySQL, is modified to
add support for \verb|JSONField|. For this backend, the \verb|DatabaseWrapper|
class is modified by adding a mapping from \verb|JSONField| to the \verb|json|
data type in the \verb|data_types| property, as shown by line 6 of
\autoref{code:backends-mysql-1}. The \verb|data_type_check_constraints|
property method is also modified to add the \verb|JSON_VALID()| function as a
\verb|CHECK| constraint for MariaDB prior to version 10.4.3, as shown by lines
15 and 16 of the listing. Later versions of MariaDB have the \verb|CHECK|
constraint automatically enabled when using the \verb|JSON| data type alias,
while MySQL automatically validates the JSON syntax when using the \verb|JSON|
data type. Therefore, there is no need to modify
\verb|data_type_check_constraints| for these systems.

\listing
{Python}
{The \code{DatabaseFeatures} class of the MySQL backend.}
{code:backends-mysql-2}
{codes/4-backends-mysql-2.py}

Meanwhile, the \verb|DatabaseFeatures| class is modified by turning
\verb|supports_json_field| into a cached property method. The method returns
\verb|True| for MariaDB version 10.2.7 or greater and MySQL version 5.7.8 or
greater (and \verb|False| otherwise), as shown by lines 4 to 8 of
\autoref{code:backends-mysql-2}. The other flags
(\verb|supports_primitives_in_json_field| and \verb|has_native_json_field|)
use the values from \verb|BaseDatabaseFeatures| as they are already correct.

\listing
{Python}
{The \code{DatabaseWrapper} class of the SQLite backend.}
{code:backends-sqlite3-1}
{codes/4-backends-sqlite3-1.py}

The \verb|DatabaseWrapper| class of the SQLite backend is modified to add the
mapping from \verb|JSONField| to \verb|text| in the \verb|data_types| property,
as shown by line 7 of \autoref{code:backends-sqlite3-1}. It is also modified to
apply the \verb|JSON_VALID()| check constraint to the database column. As the
function returns \verb|0| (false) for SQL \verb|NULL| values, an
\verb|OR "%(column)s" IS NULL| clause is added to support storing SQL
\verb|NULL| values, as shown by line 12 of the listing.

\listing
{Python}
{The \code{DatabaseFeatures} class of the SQLite backend.}
{code:backends-sqlite3-2}
{codes/4-backends-sqlite3-2.py}

Meanwhile, \verb|DatabaseFeatures| class is modified to check for JSON support
on SQLite. The \verb|supports_json_field| flag is turned into a cached property
method and the value is determined by trying to execute a \verb|SELECT| query
with the \verb|JSON()| function included in the JSON1 extension, as shown by
lines 4 to 8 of \autoref{code:backends-sqlite3-2}. If the query does not throw
an exception, it means the JSON1 extension is enabled and the flag is set to
\verb|True| (and \verb|False| otherwise), as shown by lines 9 to 11 of the
listing. The support check is done this way because SQLite does not provide a
direct way to check whether the JSON1 extension is loaded. The other flags
(\verb|supports_primitives_in_json_field| and \verb|has_native_json_field|)
are derived from \verb|BaseDatabaseFeatures|.

\listing
{Python}
{The \code{DatabaseWrapper} class of the Oracle Database backend.}
{code:backends-oracle-1}
{codes/4-backends-oracle-1.py}

For the Oracle Database backend, the \verb|DatabaseWrapper| class is modified
to add the data type mapping and \verb|CHECK| constraint. The \verb|data_types|
property is updated to map \verb|JSONField| to \verb|NCLOB|, as shown by line 7
of \autoref{code:backends-oracle-1}. The \code{NCLOB} data type is chosen to
allow data larger than 32,767 bytes and to have Unicode support
\cite{oracle:overview-json, oracle:database-concepts}. The
\verb|data_type_check_constraints| property is also updated to apply the
\verb|IS JSON| constraint for \verb|JSONField|, as shown by line 12 of the
listing.

\listing
{Python}
{The \code{DatabaseOperations} class of the Oracle Database backend.}
{code:backends-oracle-2}
{codes/4-backends-oracle-2.py}

The cx\_Oracle database driver returns \verb|CLOB| and \verb|BLOB| values from
the database as \verb|LOB| objects in Python \cite{cxoracle:lob}. Meanwhile,
the \verb|LOB| objects need to be converted to Python strings in order to
perform deserialization. To do this, the \verb|get_db_converters()| method in
the \verb|DatabaseOperations| class is overridden so that \verb|JSONField| uses
the \verb|convert_textfield_value| converter, as shown by lines 7 and 8 of
\autoref{code:backends-oracle-2}.\footnote{\code{TextField} also uses the
\code{NCLOB} data type on Oracle Database, so its converter can be reused for
\code{JSONField}.}

\listing
{Python}
{The \code{DatabaseFeatures} class of the Oracle Database backend.}
{code:backends-oracle-3}
{codes/4-backends-oracle-3.py}

As for the \verb|DatabaseFeatures| class, the \verb|supports_primitives_in_json_field|
flag is overridden to \verb|False|, as shown by line 4 of
\autoref{code:backends-oracle-2}. This flag reflects the behavior of Oracle
Database that only allows storing JSON objects and arrays in a column with the
\verb|IS JSON| constraint enabled. The other flags
(\verb|supports_json_field|\footnote{Oracle Database introduced JSON support in
version 12.1.0.2 and Django supports Oracle Database version 12.2 and higher,
so \code{JSONField} is always supported.} and \verb|has_native_json_field|) are
derived from \verb|BaseDatabaseFeatures|.

All of the database backends have now been adjusted with the necessary changes.
The changes were mostly made for mapping \verb|JSONField| to the correct data
type on the database, as well as the \verb|CHECK| constraints to ensure that
the data is valid JSON. With these changes in place, the \verb|JSONField| class
can now be implemented.

%-----------------------------------------------------------------------------%
\section{\code{JSONField}}
%-----------------------------------------------------------------------------%

In the Django codebase, model fields are defined in the
\verb|django.db.models.fields| module as subclasses of \verb|Field|, but they
can be imported from the \verb|django.db.models| module for convenience. Model
fields that are relatively simple are implemented in the \verb|__init__.py|
file of the module. For model fields that require more complex implementation
(e.g. file fields and relational fields), they are defined in their own files
in the \verb|fields| directory. Due to the complexity of \verb|JSONField| and
its extended querying capabilities, the implementation is defined in the
\verb|json.py| file in the \verb|fields| directory.

\listing
{Python}
{The \code{deconstruct()} method of \code{Field}.}
{code:field-deconstruct}
{codes/4-field-deconstruct.py}

Model fields have a \verb|deconstruct| method that defines how the field can be
reconstructed from a database migration. The method returns a 4-tuple that
consists of: the name of the field on the model, the import path of the field,
a list of positional arguments, and a dictionary of keyword arguments
\cite{django:model_fields}. By convention, model fields that are defined in
their own files like \verb|JSONField| should still be imported from
\verb|django.db.models|. Thus, the \verb|deconstruct()| method of the
\verb|Field| class is modified to shorten the path for \verb|JSONField|'s
module, as shown by lines 15 to 17 of \autoref{code:field-deconstruct}.

\listing
{Python}
{The \code{check()} method of \code{JSONField} model field.}
{code:jsonfield-check}
{codes/4-jsonfield-check.py}

The \verb|JSONField| class implements some checks to make sure that it is
used correctly. In addition to the checks included from the \verb|Field| class,
\verb|JSONField| also extends the \verb|CheckFieldDefaultMixin| class, as shown
by line 1 of \autoref{code:jsonfield-check}. The mixin adds a check to ensure
that any default value set for the field should be a callable instead of an
instance, so that it's not shared between all instances of the field. The
\verb|JSONField| class also overrides the \verb|check()| method to include the
\verb|_check_supported()| method in the checking process, as shown by lines 4
to 8 of the listing.

\listing
{Python}
{The \code{\_check\_supported()} method of \code{JSONField} model field.}
{code:jsonfield-checksupported}
{codes/4-jsonfield-checksupported.py}

The \verb|_check_supported()| method checks all of the connected databases for
\verb|JSONField| support. If migrations for the model (that the field is
attached to) are not allowed on the database by the database router, then the
database is skipped from the check, as shown by lines 4 and 5 of
\autoref{code:jsonfield-checksupported}. Otherwise, the
\verb|supports_json_field| feature flag is checked. Lines 7 to 17 show that if
the flag's value is \verb|False| and the model is not explicitly defined to
require the feature flag, then a system error is added to the lists of errors
to be returned by the \verb|check| method and shown to the programmer.

\listing
{Python}
{The \code{get\_internal\_type()} method of \code{JSONField} model field.}
{code:jsonfield-getinternaltype}
{codes/4-jsonfield-getinternaltype.py}

To determine the key that is used to get the data type and check constraints
from the database backends, the \verb|get_internal_type()| method is used. By
default, the method returns the name of the class (using
\verb|self.__class__.__name__|), so it is not necessary to override it.
However, other model fields override the method to explicitly return the name
of the class, so that other classes may extend the model fields without having
to override the \verb|get_internal_type()| method unless it is needed. Thus,
the \verb|get_internal_type()| method is overridden to explicitly return the
string \verb|'JSONField'|, as shown by line 2 of
\autoref{code:jsonfield-getinternaltype}.

\listing
{Python}
{The \code{get\_prep\_value()} method of \code{JSONField} model field.}
{code:jsonfield-ser}
{codes/4-jsonfield-ser.py}

In the previous chapter, \verb|JSONField| is designed to serialize Python
objects into JSON-encoded strings by utilizing the built-in \verb|json| library
in Python. The serialization process is needed in order to store Python objects
as JSON in the database. To convert Python objects to query values, the
\verb|get_prep_value()| method should be overridden. The serialization is shown
by line 4 of \autoref{code:jsonfield-ser}, where the Python object is passed
to the \verb|json.dumps()| function, which also accepts an optional encoder
class as the \verb|cls| argument. Lines 2 and 3 of the listing show that the
\verb|None| value should not be serialized, because it is reserved for SQL
\verb|NULL| as previously explained.

\listing
{Python}
{The \code{value\_to\_string()} method of \code{JSONField} model field.}
{code:jsonfield-valuetostring}
{codes/4-jsonfield-valuetostring.py}

In addition to the serialization needed to store a Python object inside
\verb|JSONField| to the database, Django also has a serialization framework
that can be used for model objects. The framework can be used to dump model
objects into XML, JSON, and YAML files. The model objects are serialized by
calling the \verb|value_to_string()| method of their fields. Normally, the
method returns a string that is ready to be used by the serializer. However,
\verb|JSONField| represents JSON data in its Python built-in format that
can be serialized by the built-in serializers. Therefore, the method should
just return the Python object as-is and let the serializers handle the
serialization process. To achieve this, the \verb|value_to_string()| method
is overridden to just return the object using the \verb|value_from_object()|
method, as shown by line 2 of \autoref{code:jsonfield-valuetostring}.

\listing
{Python}
{The \code{from\_db\_value()} method of \code{JSONField} model field.}
{code:jsonfield-des}
{codes/4-jsonfield-des.py}

\verb|JSONField| is also designed to deserialize JSON-encoded strings to Python
objects in order to load the JSON data from the database. To convert database
values to Python objects, the \verb|from_db_value()| method can be overridden.
On some database systems that have a native JSON data type, the database driver
may already deserialize the value before Django receives it.\footnote{Only
PostgreSQL's Psycopg 2 driver does this at the time of writing, but this may
change in the future.} Lines 4 and 5 of \autoref{code:jsonfield-des} show that
the value is returned as-is, unless a custom decoder is used. In other cases,
the deserialization process is shown by line 7 of the listing, where
the database value is passed to the \verb|json.loads()| function, which also
accepts an optional decoder class as the \verb|cls| argument. Similar to
\verb|get_prep_value()|, the \verb|None| value is reserved for SQL \verb|NULL|,
as shown by lines 2 and 3 of the listing.

When extracting JSON string values, the database systems return them as
deserialized values (i.e. without JSON double quotes). Passing deserialized
strings to \verb|json.loads()| may cause \verb|json.JSONDecodeError| to be
raised. Therefore, as shown by lines 7 to 10 of \autoref{code:jsonfield-des},
the \verb|json.loads()| call is put inside a \verb|try ... except| block and
the value is directly returned if \verb|json.JSONDecodeError| is raised.

\listing
{Python}
{The \code{select\_format()} method of \code{JSONField}.}
{code:jsonfield-selectformat}
{codes/4-jsonfield-selectformat.py}

To cast JSON data to \verb|text| on the database level, the
\verb|select_format()| method is overridden in the \verb|JSONField| class. As
the name suggests, this method determines the format of the \verb|SELECT|
clause of the SQL query. The casting operation is needed in order to enable the
use of a custom decoder with a database system that automatically deserializes
JSON data into Python objects. Thus, the casting operation is performed only if
a custom decoder is used with a database backend that has the
\verb|has_native_json_field| feature flag set to \verb|True|, as shown by lines
2 to 6 of \autoref{code:jsonfield-selectformat}.

\listing
{Python}
{The \code{\_\_init\_\_()} method (constructor) of \code{JSONField}
model field.}
{code:jsonfield-init}
{codes/4-jsonfield-init.py}

The custom encoder and decoder are stored as instance attributes of the field,
as shown by lines 13 and 14 of \autoref{code:jsonfield-init}. It is important
to note that the encoder and decoder are subclasses of \verb|json.JSONEncoder|
and \verb|json.JSONDecoder|, rather than instances of those classes. In Python,
a class is a callable that returns an instance of the class, so the encoder and
decoder have to be callables. To enforce this requirement, the \verb|JSONField|
constructor checks whether the encoder and decoder are callables and raises
descriptive error messages if they are not, as shown by lines 5 to 12 of the
listing.

\listing
{Python}
{The \code{deconstruct()} method of \code{JSONField} model field.}
{code:jsonfield-dec}
{codes/4-jsonfield-dec.py}

In order to preserve the encoder and decoder classes in database migrations,
the \verb|deconstruct()| method needs to be overridden. The encoder and decoder
are defined as keyword arguments of the constructor. Therefore, the
\verb|deconstruct()| method is overridden to add the encoder and decoder
classes (if they are set, i.e. not \verb|None|) to the keyword arguments
dictionary, as shown by lines 3 to 6 of \autoref{code:jsonfield-dec}.

\listing
{Python}
{The \code{\_\_init\_\_()} method (constructor) of \code{JSONField} form field.}
{code:formfield-init}
{codes/4-formfield-init.py}

The \verb|JSONField| form field has also been updated to support custom encoder
and decoder. As with the model field, the encoder and decoder classes are
stored as instance attributes of the form field, as shown by lines 8 and 9 of
\autoref{code:formfield-init}. The encoder and decoder classes are used in
\verb|json.dumps()| and \verb|json.loads()| calls throughout the form field,
respectively.

\listing
{Python}
{The \code{prepare\_value()} and \code{has\_changed()} methods of
\code{JSONField} form field.}
{code:formfield-dumps}
{codes/4-formfield-dumps.py}

To utilize a custom encoder, some of the \verb|JSONField| form field methods
had to be updated. Line 4 of \autoref{code:formfield-dumps} shows the encoder
class used in the \verb|json.dumps()| call inside the \verb|prepare_value()|
method, which is used to prepare the value before it is shown to the user (e.g.
in an HTML form). Lines 12 and 13 show the encoder class used in the
\verb|json.dumps()| calls inside the \verb|has_changed()| method, which is used
to check whether the value inside the form field has changed.

\listing
{Python}
{The \code{to\_python()} and \code{bound\_data()} methods of \code{JSONField}
form field.}
{code:formfield-loads}
{codes/4-formfield-loads.py}

Some of the \verb|JSONField| form field methods also had to be updated to
support the use of a custom decoder. Line 4 of \autoref{code:formfield-loads}
shows the decoder class used in the \verb|json.loads()| call inside the
\verb|to_python()| method, which is used in the form field validation process.
If the value cannot be deserialized with the decoder, a \verb|ValidationError|
is raised, as shown by lines 5 to 10. Line 16 shows the decoder class used in
the \verb|json.loads()| call inside the \verb|bound_data()| method, which is
used to load the input data to the form field.

The form field only handles user input and does not interact with the database
directly. Thus, it is possible to use it with any database backend. As a
result, the form field has now been moved from the
\verb|django.contrib.postgres.forms| module to the \verb|django.forms| module.

\listing
{Python}
{The \code{formfield()} method of \code{JSONField} model field.}
{code:jsonfield-form}
{codes/4-jsonfield-form.py}

When model fields are included in a \verb|ModelForm|, Django automatically
generate form fields for them \cite{django:modelform}. The form fields are
generated by calling the \verb|formfield()| method of the model fields. In
order to use the encoder and decoder from the \verb|JSONField| model field in
the \verb|JSONField| form field, they need to be passed as keyword arguments,
as shown by lines 4 and 5 of \autoref{code:jsonfield-form}.

\listing
{Python}
{The \code{validate()} method of \code{JSONField} model field.}
{code:jsonfield-validate}
{codes/4-jsonfield-validate.py}

Model fields can define a built-in validation mechanism in the
\verb|validate()| method. The method is called by the field's \verb|clean()|
method as part of the model validation process of a \verb|ModelForm|. For
\verb|JSONField|, the \verb|validate()| method is overridden to provide a
basic validation mechanism by trying to serialize the field's value with the
given encoder, as shown by lines 3 and 4 of \autoref{code:jsonfield-validate}.
Lines 5 to 10 of the listing show that if the serialization fails, then a
\verb|ValidationError| is raised.

Now that the \verb|JSONField| class has been implemented, it is possible to
store and load JSON data to and from the database. As explained in the previous
chapter, there are also lookups and transforms that are specific for
\verb|JSONField|. The lookups and transforms extend the querying capabilities
for \verb|JSONField| by utilizing the functions and operators available on the
database systems. The implementation of the lookups and transforms will be
explained in the next section.

%-----------------------------------------------------------------------------%
\section{\code{JSONField} Lookups and Transforms}
%-----------------------------------------------------------------------------%

Lookups and transforms are part of Django's query expressions API. The API
consists of classes which instances can be compiled by Django's
\verb|SQLCompiler| objects. An \verb|SQLCompiler| object translates a query
expression by calling its \verb|as_vendorname()|\footnote{The \code{vendorname}
is the value of the \code{vendor} attribute in the \code{DatabaseWrapper} class
of the database backend, i.e. \code{postgresql}, \code{mysql}, \code{sqlite},
and \code{oracle}.} method (for vendor-specific implementation) if it exists,
and falls back to the \verb|as_sql()| method otherwise.

The lookups and transforms in this research are specific to \verb|JSONField|.
Normally, lookups and transforms are implemented in the
\verb|django.db.models.lookups| module. In the module, lookups are implemented
as subclasses of the \verb|Lookup| class, while transforms are implemented as
subclasses of the \verb|Transform| class. However, as the lookups and
transforms in this research are specific to \verb|JSONField|, they are
implemented as part of the \verb|django.db.models.fields.json| module.

The existing lookups for the PostgreSQL-only \verb|JSONField| serve as the
basis for the new implementation. The lookups are the containment lookups
(\verb|__contains| and \verb|__contained_by|), as well as the key existence
lookups (\verb|has_key|, \verb|has_keys|, and \verb|has_any_keys|). In addition
to that, the \verb|__exact| lookup also has to be overridden in order to
support the JSON \verb|null| value.

The transforms are the key, index, and path transforms that extract the value
of JSON data at a given path. The index transform is just a special case of
the key transform where the key is an integer. Meanwhile, the path transform
can be viewed as a chain of key transforms. Therefore, the transforms are
unified as \verb|KeyTransform| in the existing implementation. The value
extracted by the transforms can be chained with some of the built-in lookups
and the \verb|JSONField|-specific lookups. As these transforms may return
values of different data types, some of the lookups also need to be modified
when they are used with on a \verb|KeyTransform|.

The lookups can be used directly on a \verb|JSONField| or on
\verb|KeyTransform|s applied to the field. When some of the lookups are used on
the transforms, they are implemented differently. Thus, before going in-depth
with the lookups implementation, it is better to go through the transforms
first.

\listing
{Python}
{Parts of the \code{KeyTransform} class.}
{code:keytransform-1}
{codes/4-keytransform-1.py}

The key, index, and path
transforms are unified as the \verb|KeyTransform| class, which can be used to
extract the value of a \verb|JSONField| at a given path. The class includes the
{PostgreSQL} operators for extracting JSON values as shown by lines 2 and 3
of \autoref{code:keytransform-1}. Line 7 shows that the key name is normalized
as a string on initialization.

\listing
{Python}
{The \code{preprocess\_lhs()} method of the \code{KeyTransform} class.}
{code:keytransform-2}
{codes/4-keytransform-2.py}

To process a chain of \verb|KeyTransform|s that make up a path transform, the
\verb|preprocess_lhs()| method is created. Lines 4 to 8 of
\autoref{code:keytransform-2} show how the method separates the chain of
\verb|KeyTransform|s from the previous \verb|lhs|. The separation is done by
traversing the \verb|lhs| attribute of the \verb|KeyTransforms| until the
\verb|lhs| is not a \verb|KeyTransform|. While traversing, the key names that
construct the path are saved into a list. The method then compiles the original
\verb|lhs| and its parameters, and return them along with the list of
\verb|KeyTransforms|, as shown by lines 9 and 12. Lines 10 and 11 show that on
Oracle Database, any \verb|%| character in the key name is replaced by
\verb|%%| to escape string formatting (this will be explained later). In
addition, the method also has an \verb|lhs_only| parameter for optimization by
not saving and returning the key names if they are not needed, as shown by
lines 1, 2, 6, and 12.

\listing
{Python}
{The \code{as\_postgresql()} method of the \code{KeyTransform} class.}
{code:keytransform-3}
{codes/4-keytransform-3.py}

To compile a \verb|KeyTransform| into an SQL query expression, the
\verb|as_vendor()| method is used, e.g. \verb|as_postgresql()| for the
PostgreSQL backend. The method uses the \verb|preprocess_lhs()| method
described previously, as shown by line 2 of \autoref{code:keytransform-3}. If
there are multiple \verb|KeyTransform|s, the \verb|postgres_nested_operator|
(\verb|#>|) is used, as shown by lines 3 to 7 of the listing. Otherwise, the
\verb|postgres_operator| (\verb|->|) is used, as shown by lines 12 to 15. For
consistency, if there is only one \verb|KeyTransform| and the key is an
integer, it is assumed to be an array index by converting it to the \verb|int|
data type, as shown by line 9. The conversion is not needed for the nested
operator because for this operator, PostgreSQL automatically interprets integer
key names as array indices.

\listing
{Python}
{The \code{compile\_json\_path()} function.}
{code:compilejsonpath}
{codes/4-compilejsonpath.py}

On other database systems, the JSON extraction functions use the JSONPath
notation to specify the path to be extracted. For reusability, the
\verb|compile_json_path()| function is created to convert a list of key names
into its JSONPath representation. The function works by iterating through the
list of key names and keeping a list of strings that make up the JSONPath. If
the key name is an integer, the string \verb|'[num]'| (where \verb|num| is the
integer) is appended to the list, as shown by lines 4, 5, 9, and 10 of
\autoref{code:compilejsonpath}. Otherwise, the key name is enclosed in double
quotes (so that it may contain spaces) by passing it through
\verb|json.dumps()|, as shown by lines 6 to 8. Additionally, the method also
has a \verb|include_root| parameter to control whether the resulting path
should include the root notation (\verb|$|), as shown by lines 1 and 2.
Finally, the list of strings is concatenated by joining the strings with an
empty string, as shown by line 11.

\listing
{Python}
{The \code{as\_mysql()} and \code{as\_sqlite()} methods of the \code{KeyTransform} class.}
{code:keytransform-4}
{codes/4-keytransform-4.py}

The \verb|as_vendor()| methods for MariaDB, MySQL, and SQLite are similar. The
methods utilize the \verb|preprocess_lhs()| method and
\verb|compile_json_path()| to construct the JSONPath notation of the key
transforms, as shown by lines 2, 3, 7, and 8 of \autoref{code:keytransform-4}.
To extract the value, the \verb|JSON_EXTRACT()| function is used, where the
first argument is the \verb|lhs| and the second argument is the JSONPath, as
shown by lines 4 and 9.

\listing
{Python}
{The \code{as\_oracle()} method of the \code{KeyTransform} class.}
{code:keytransform-5}
{codes/4-keytransform-5.py}

Meanwhile, the \verb|as_oracle()| method needs some adjustments to work with
the behavior of Oracle Database. The method still uses the
\verb|preprocess_lhs()| method and \verb|compile_json_path()| function, as
shown by lines 2 and 3 of \autoref{code:keytransform-5}. However, to extract
the value, the \verb|JSON_QUERY()| and \verb|JSON_VALUE()| functions are
combined using the \verb|COALESCE()| function. This approach is needed as there
is no way to tell whether the value at the given path is a JSON object/array or
a scalar value. In addition, the path argument is added directly to the SQL
string, as shown by lines 5 and 6, because path expressions cannot be passed as
bind variables on Oracle Database \cite{oracle:jsonpath}.

\listing
{Python}
{The \code{PostgresOperatorLookup} class.}
{code:pgop-lookup}
{codes/4-pgop-lookup.py}

In the existing PostgreSQL-only implementation, \verb|JSONField| lookups mostly
used a simple \verb|<lhs> <operator> <rhs>| format in the SQL queries sent to
the database (e.g. \verb|json_column @> '{"foo": "bar"}')|. To simplify the
implementation, a \code{PostgresSimpleLookup} class was created, so that the
lookups only needed to extend from the class and specify the operator. To
facilitate this research, the Django developers have moved this class from
\verb|django.contrib.postgres.lookups| to \verb|django.db.models.lookups| and
renamed the class to \verb|PostgresOperatorLookup|
\cite{gh-django:pgop-lookup}. By moving the class, the new implementation can
reuse the same logic without having to rely on the
\verb|django.contrib.postgres| module.

\listing
{Python}
{The new flags for the \code{JSONField} lookups in the \code{BaseDatabaseFeatures} class.}
{code:basedbfeatures2}
{codes/4-basedbfeatures2.py}

In addition to the database feature flags added to implement \verb|JSONField|,
there are some more of them added to implement the lookups, as shown by
\autoref{code:basedbfeatures2}. The first flag is \verb|has_json_operators|
that indicates whether the backend uses PostgreSQL-style JSON operators (e.g.
\verb|->|), which is set to \verb|False| and only overridden to \verb|True| for
PostgreSQL. The second flag is \verb|supports_json_field_contains| that
indicates whether the backend supports the containment lookups for
\verb|JSONField|. This flag is set to \verb|True| and overridden to
\verb|False| for SQLite and Oracle Database because they don't support the
containment lookups, as explained in the previous chapter. The last flag is the
\verb|json_key_contains_list_matching_requires_list| that indicates whether the
\verb|__contains| lookup requires matching object structure. This flag is set
to \verb|False| and only overridden to \verb|True| for PostgreSQL as it is the
only system with the described behavior \cite{postgres:json}. Of the three
flags added above, the only flag used in the lookups implementation is
\verb|supports_json_field_contains|, while the others are only used in tests.
