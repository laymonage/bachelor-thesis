%-----------------------------------------------------------------------------%
\chapter{\babEmpat}
%-----------------------------------------------------------------------------%

This chapter explains the implementation of \code{JSONField} and
\code{JSONField}-specific lookups and transforms that can be used on all
database backends supported by Django.

%-----------------------------------------------------------------------------%
\section{\code{JSONField}}
%-----------------------------------------------------------------------------%

In the Django codebase, model fields are defined in the
\code{django.db.models.fields} module as subclasses of \code{Field}, but they
can be imported from the \code{django.db.models} module for simplicity. Model
fields that are relatively simple are implemented in the \verb|__init__.py|
file of the module. For model fields that require more complex implementation
(e.g. file fields and relational fields), they are defined in their own files
in the \code{fields} directory. Due to the complexity of \code{JSONField} and
its extended querying capabilities, the implementation is defined in the
\code{json.py} file in the \code{fields} directory.

\listing
{Python}
{The \code{get\_prep\_value()} method of \code{JSONField}.}
{code:jsonfield-ser}
{codes/4-jsonfield-ser.py}

In the previous chapter, \code{JSONField} is designed to serialize Python
objects into JSON-encoded strings by utilizing the built-in \code{json} library
in Python. The serialization process is needed in order to store Python objects
as JSON in the database. To convert Python objects to query values, the
\verb|get_prep_value()| method should be overridden. The serialization is shown
by line 7 of \autoref{code:jsonfield-ser}, where the Python object is passed
to the \verb|json.dumps()| function, which also accepts an optional encoder
class as the \verb|cls| argument. Lines 5 and 6 of the listing show that the
\verb|None| value should not be serialized, because it is reserved for SQL
\verb|NULL| as previously explained.

\listing
[0 pt]{Python}
{The \code{from\_db\_value()} method of \code{JSONField}.}
{code:jsonfield-des}
{codes/4-jsonfield-des.py}

\verb|JSONField| is also designed to deserialize JSON-encoded strings to Python
objects in order to load the JSON data from the database. To convert database
values to Python objects, the \verb|from_db_value()| method can be overridden.
The deserialization process is shown by line 8 of \autoref{code:jsonfield-des},
where the database value is passed to the \verb|json.loads()| function, which
also accepts an optional decoder class as the \verb|cls| argument. Similar to
\verb|get_prep_value()|, the \verb|None| value is reserved for SQL \verb|NULL|,
as shown by lines 5 and 6 of \autoref{code:jsonfield-des}.

When extracting JSON scalar values, the database systems return them as
deserialized values. Passing deserialized values to \verb|json.loads()| may
cause \verb|json.JSONDecodeError| to be raised. Therefore, as shown by lines 7
to 10 of \autoref{code:jsonfield-des}, the \verb|json.loads()| call is put
inside a \verb|try ... except| block and the value is directly returned if
\verb|json.JSONDecodeError| is raised.

\listing
{Python}
{The \code{\_\_init\_\_()} method (constructor) of \code{JSONField}.}
{code:jsonfield-init}
{codes/4-jsonfield-init.py}

The custom encoder and decoder are stored as instance attributes of the field,
as shown by lines 16 and 17 of \autoref{code:jsonfield-init}. It is important
to note that the encoder and decoder are subclasses of \verb|json.JSONEncoder|
and \verb|json.JSONDecoder|, rather than instances of those classes. In Python,
a class is a callable that returns an instance of the class, so the encoder and
decoder have to be callables. To enforce this requirement, the \verb|JSONField|
constructor checks whether the encoder and decoder are callables and raises
descriptive error messages if they are not, as shown by lines 8 to 15 of the
listing.

\listing
{Python}
{The \code{deconstruct()} method of \code{JSONField}.}
{code:jsonfield-dec}
{codes/4-jsonfield-dec.py}

In order to preserve the encoder and decoder classes in database migrations,
the \verb|deconstruct()| method needs to be overridden. The method returns a
4-tuple that consists of: the name of the field on the model, the import path
of the field, a list of positional arguments, and a dictionary of keyword
arguments \cite{django:model_fields}. These values will be used to reconstruct
the field from a database migration. The encoder and decoder are defined as
keyword arguments of the constructor. Therefore, the \verb|deconstruct()|
method is overridden to add the encoder and decoder classes (if they are set,
i.e. not \verb|None|) to the keyword arguments dictionary, as shown by lines 6
to 9 of \autoref{code:jsonfield-dec}.

\listing
{Python}
{The \code{formfield()} method of \code{JSONField}.}
{code:jsonfield-form}
{codes/4-jsonfield-form.py}

When model fields are included in a \verb|ModelForm|, Django automatically
generate form fields for them. The form fields are generated by calling the
\verb|formfield()| method of the model fields. In order to use the encoder and
decoder from the \verb|JSONField| model field in the \verb|JSONField| form
field, they need to be passed as keyword arguments, as shown by lines 7 and 8
of \autoref{code:jsonfield-form}.
